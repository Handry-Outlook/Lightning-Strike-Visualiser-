<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="utf-8">
  <title>Lightning Strike Visualiser⚡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <link href="https://cdn.maptiles.com/maptiler-sdk-js/v3.0.1/maptiler-sdk.css" rel="stylesheet" />
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <style>
    .draw-toolbar {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .draw-toolbar button {
    background: #3b82f6;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
  }
  .draw-toolbar button:hover {
    background: #2563eb;
  }
  .draw-toolbar select {
    padding: 6px;
    border-radius: 4px;
    font-size: 0.9em;
  }
  #polygon-controls {
    background: #ffffff;
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 15px;
    transition: background 0.3s ease, color 0.3s ease;
  }
  body.dark-mode #polygon-controls {
    background: #2a2a2a;
    color: #e0e0e0;
  }
  .leaflet-draw {
    z-index: 1003;
  }
  .leaflet-draw-toolbar {
    display: none !important; /* Hide default Leaflet.draw toolbar */
  }
  .polygon-popup input, .polygon-popup select, .polygon-popup button {
    margin: 5px 0;
    padding: 5px;
    width: 100%;
    box-sizing: border-box;
  }
  @media (max-width: 768px) {
    .draw-toolbar {
      flex-direction: column;
      align-items: flex-start;
    }
    #top-bar .draw-toolbar {
      display: none;
    }
    #control-panel .draw-toolbar {
      display: flex;
    }
  }
  @media (min-width: 769px) {
    #control-panel .draw-toolbar {
      display: none;
    }
    #top-bar .draw-toolbar {
      display: flex;
    }
  }
    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      background: #f4f7fa;
      overflow-x: hidden;
      transition: background 0.3s ease, color 0.3s ease;
    }
    body.dark-mode {
      background: #1a1a1a;
      color: #e0e0e0;
    }
    #top-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #283673;
      padding: 10px 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      z-index: 1002;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-sizing: border-box;
      transition: background 0.3s ease;
    }
    body.dark-mode #top-bar {
      background: #2a2a2a;
    }
    #top-bar h2 {
      margin: 0;
      color: #ffffff;
      font-weight: 600;
      font-size: 1.2em;
      flex-shrink: 0;
    }
    #top-bar div {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
      flex-wrap: nowrap;
      max-width: 50%;
    }
    #top-bar button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      flex-shrink: 0;
      margin-right: 5px;
    }
    #top-bar button:hover {
      background: #2563eb;
    }
    .logo {
      width: 80px;
      pointer-events: none;
      z-index: 1002;
    }
    @media (min-width: 769px) {
      .logo {
        position: absolute;
        bottom: 20px;
        right: 8px;
      }
    }
    @media (max-width: 768px) {
      .logo {
        position: absolute;
        top: 60px;
        left: 10px;
      }
    }
    #map, #map-3d {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      border-radius: 8px;
    }
    #map-3d {
      display: none;
    }
    #control-panel {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 1003;
      padding: 10px;
      transition: background 0.3s ease, color 0.3s ease;
    }
    body.dark-mode #control-panel {
      background: #2a2a2a;
      color: #e0e0e0;
    }
    @media (min-width: 769px) {
      #control-panel {
        position: fixed;
        top: 60px;
        left: 20px;
        width: 300px;
        height: calc(100% - 80px);
        overflow-y: auto;
      }
      #map, #map-3d {
        left: 340px;
        width: calc(100% - 340px);
      }
    }
    @media (max-width: 768px) {
      #control-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        overflow-y: auto;
      }
      #control-panel.open {
        display: block;
      }
      #settings-button {
        position: fixed;
        bottom: 145px;
        right: 50px;
        background: #3b82f6;
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 1.2em;
        cursor: pointer;
        z-index: 1004;
      }
      #settings-button:hover {
        background: #2563eb;
      }
      #fullscreen-button, .fullscreen-toggle {
        display: none;
      }
    }
    .section {
      margin-bottom: 15px;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 10px;
    }
    body.dark-mode .section {
      border-bottom: 1px solid #444;
    }
    .section h4 {
      margin: 0 0 10px;
      color: #1a2a44;
      font-weight: 600;
      font-size: 0.9em;
    }
    body.dark-mode .section h4 {
      color: #e0e0e0;
    }
    .control-panel label {
      display: flex;
      flex-direction: column;
      font-size: 0.8em;
      color: #1a2a44;
      font-weight: 500;
      margin-bottom: 8px;
      position: relative;
    }
    body.dark-mode .control-panel label {
      color: #e0e0e0;
    }
    .control-panel label span.tooltip {
      display: none;
      position: absolute;
      top: -30px;
      left: 0;
      background: #333;
      color: white;
      padding: 5px;
      border-radius: 4px;
      font-size: 0.7em;
      white-space: nowrap;
    }
    body.dark-mode .control-panel label span.tooltip {
      background: #555;
    }
    .control-panel label:hover span.tooltip {
      display: block;
    }
    .control-panel input, .control-panel select, .control-panel button {
      margin-top: 3px;
      padding: 6px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.8em;
      background: #fff;
      color: #1a2a44;
      transition: background 0.3s ease, color 0.3s ease, border 0.3s ease;
    }
    body.dark-mode .control-panel input,
    body.dark-mode .control-panel select,
    body.dark-mode .control-panel button {
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
    }
    .control-panel input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      background: #d1d5db;
      border-radius: 4px;
      outline: none;
      transition: background 0.3s ease;
    }
    body.dark-mode .control-panel input[type="range"] {
      background: #555;
    }
    .control-panel input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }
    .control-panel input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }
    .control-panel input[type="checkbox"] {
      margin-top: 3px;
      accent-color: #3b82f6;
    }
    .control-panel button, #remove-filter {
      background: #3b82f6;
      color: white;
      border: none;
      cursor: pointer;
    }
    .control-panel button:hover, #remove-filter:hover {
      background: #2563eb;
    }
    #expert-controls {
      display: none;
      padding: 10px;
      background: #f9fafb;
      border-radius: 6px;
      transition: background 0.3s ease;
    }
    body.dark-mode #expert-controls {
      background: #333;
    }
    .time-slider-container {
      position: fixed;
      bottom: 20px;
      background: #ffffff;
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 1001;
      display: flex;
      flex-direction: column;
      gap: 6px;
      box-sizing: border-box;
      transition: background 0.3s ease, color 0.3s ease;
    }
    body.dark-mode .time-slider-container {
      background: #2a2a2a;
      color: #e0e0e0;
    }
    @media (min-width: 769px) {
      .time-slider-container {
        left: 340px;
        width: calc((100% - 340px) * 0.8);
        left: calc(340px + ((100% - 340px) - ((100% - 340px) * 0.8)) / 2);
      }
    }
    @media (max-width: 768px) {
      .time-slider-container #history-time {
        font-size: 0.7em;
      }
      .time-slider-container {
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
      }
    }
    .time-slider-container .animator {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .time-slider-container button {
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px;
      cursor: pointer;
    }
    .time-slider-container button:hover {
      background: #2563eb;
    }
    .slider {
      width: 100%;
      -webkit-appearance: none;
      height: 8px;
      background: #d1d5db;
      border-radius: 4px;
      outline: none;
      transition: background 0.3s ease;
    }
    body.dark-mode .slider {
      background: #555;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }
    .slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
    }
    .time-slider-container .status-info {
      font-size: 0.75em;
      color: #1a2a44;
      margin: 0;
    }
    body.dark-mode .time-slider-container .status-info {
      color: #e0e0e0;
    }
    .status-info-container {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 4px;
    }
    .legend {
      background: rgba(255,255,255,0.95);
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      font-size: 0.75em;
      color: #1a2a44;
      max-width: 125px;
      min-width: 110px;
      position: absolute;
      top: 60px;
      right: 10px;
      z-index: 1002;
      display: none;
      transition: background 0.3s ease, color 0.3s ease;
    }
    body.dark-mode .legend {
      background: rgba(40,40,40,0.95);
      color: #e0e0e0;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }
    .color-box {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 8px;
      vertical-align: middle;
    }
    .gradient-bar {
      height: 10px;
      width: 100%;
    }
    .modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1005;
      max-width: 90%;
      transition: background 0.3s ease, color 0.3s ease;
    }
    body.dark-mode .modal {
      background: #2a2a2a;
      color: #e0e0e0;
    }
    #tutorial-modal {
      max-height: 80vh;
      overflow-y: auto;
      width: 70%;
      max-width: 70vh;
      padding: 20px;
    }
    @media (max-width: 768px) {
      #tutorial-modal {
        width: 70%;
        max-height: 85vh;
        padding: 15px;
      }
    }
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1004;
    }
    .hidden {
      display: none;
    }
    #fullscreen-button {
      position: fixed;
      bottom: 20px;
      right: 10px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 1.2em;
      cursor: pointer;
      z-index: 1004;
    }
    .user-location-marker {
      background-color: #3b82f6;
      border-radius: 50%;
      width: 12px;
      height: 12px;
      box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.5);
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.5); }
      70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
      100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
    }
    .fullscreen #map, .fullscreen #map-3d {
      width: 100vw;
      height: 100vh;
      left: 0;
    }
    .fullscreen #control-panel {
      display: none;
    }
    .fullscreen .time-slider-container {
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
    }
    #map {
    position: absolute;
    top: 60px;
    bottom: 0;
    width: 100%;
    z-index: 1;
    transition: opacity 0.3s ease;
  }
  #map3D {
    position: absolute;
    top: 60px;
    bottom: 0;
    width: 100%;
    z-index: 2;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  body.three-d-mode #map {
    opacity: 0; /* Hide 2D map but keep it functional */
    pointer-events: none; /* Prevent interactions except for popups */
    height: 0; /* Minimize impact on layout */
    overflow: hidden;
  }
  body.three-d-mode #map3D {
    opacity: 1; /* Show 3D map */
  }
  .mapboxgl-ctrl-group {
    z-index: 1100 !important; /* Ensure mapbox-gl-draw controls are above top bar */
    margin-top: 70px !important; /* Move controls below top bar */
  }
  
  </style>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-M5QDT7XR39"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-M5QDT7XR39');
</script>
<body>
  <div id="top-bar">
    <div class="draw-toolbar">
  <button onclick="toggleDrawing()">Enable Drawing</button>
  <select id="risk-level-select">
    <option value="Low risk">Low risk</option>
    <option value="Slight risk">Slight risk</option>
    <option value="Enhanced risk">Enhanced risk</option>
    <option value="Moderate risk">Moderate risk</option>
    <option value="High risk">High risk</option>
    <option value="Severe risk">Severe risk</option>
  </select>
  <button onclick="exportToKML()">Export KML</button>
</div>

    <div>
      <button onclick="toggleDarkMode()">🌙 Dark Mode</button>
      <button onclick="toggleLegend()">Legend</button>
      <button onclick="showTutorial()">Help</button>
      <button onclick="showUserLocation()">📍</button>
      <button class="fullscreen-toggle" onclick="toggleFullScreen()">⛶</button>
    </div>
  </div>
  <div id="control-panel" class="control-panel">
    <div class="section">
      <div id="polygon-controls" class="section">
  <h4>Polygon Drawing</h4>
  <label>Enable Polygons: <input type="checkbox" id="drawn-polygons-toggle" checked onchange="toggleDrawnPolygons()"><span class="tooltip">Show/hide drawn polygons</span></label>
  <label>Opacity: <input type="range" id="polygon-opacity" min="0" max="1" step="0.1" value="0.3" onchange="updateAllPolygonsOpacity()"><span class="tooltip">Adjust polygon fill opacity</span></label>
  <label>Outline Thickness: <input type="range" id="polygon-weight" min="1" max="10" step="1" value="2" onchange="updateAllPolygonsWeight()"><span class="tooltip">Adjust polygon outline thickness</span></label>
  <div class="draw-toolbar">
    <button onclick="toggleDrawing()">Enable Drawing</button>
    <select id="risk-level-select">
      <option value="Low risk">Low risk</option>
      <option value="Slight risk">Slight risk</option>
      <option value="Enhanced risk">Enhanced risk</option>
      <option value="Moderate risk">Moderate risk</option>
      <option value="High risk">High risk</option>
      <option value="Severe risk">Severe risk</option>
    </select>
    <button onclick="exportToKML()">Export KML</button>
  </div>
</div>
      <h4>Time Filter</h4>
      <label>Start Time: <input type="datetime-local" id="start-time"><span class="tooltip">Filter strikes from this time</span></label>
      <label>End Time: <input type="datetime-local" id="end-time"><span class="tooltip">Filter strikes up to this time</span></label>
      <button onclick="applyFilter()">Apply Filter</button>
      <button id="remove-filter" onclick="removeTimeFilter()" style="display: none;">Remove Filter</button>
      <label>Auto Time Filter: <input type="checkbox" id="auto-time-filter" checked><span class="tooltip">Auto-adjust time based on uploaded files</span></label>
      <label>Lightning Lifespan: <input type="number" id="lightning-lifespan" value="3" min="0.1" step="0.1"> hours<span class="tooltip">Show strikes within this period</span></label>
      <label>Max History: <input type="number" id="max-history-hours" value="48" min="1" step="1" onchange="updateHistorySliderMax()"> hours<span class="tooltip">Max hours back for slider</span></label>
    </div>
    <div class="section">
      <h4>Layers</h4>
      <label>Color by Age: <input type="checkbox" id="color-mode" checked onchange="updateStrikeColors()"><span class="tooltip">Color strikes by age</span></label>
      <label>Lightning Layer: <input type="checkbox" id="lightning-layer-toggle" checked onchange="toggleLightningLayer()"><span class="tooltip">Show lightning strikes</span></label>
      <label>Heatmap: <input type="checkbox" id="heatmap-toggle" onchange="toggleHeatmap()"><span class="tooltip">Show 2D heatmap</span></label>
      <label id="heatmap-3d-toggle-label">3D Heatmap: <input type="checkbox" id="heatmap-3d-toggle" onchange="updateHeatmap(currentFiltered)"><span class="tooltip">Show 3D heatmap in 3D mode</span></label>
      <label>Overlay Numbers: <input type="checkbox" id="number-overlay-toggle" onchange="updateOverlay(currentFiltered)"><span class="tooltip">Show strike counts</span></label>
      <label>Map Style: <select id="map-style" onchange="switchBaseMap(this.value)">
        <option value="mapbox" selected>Mapbox (Handry Outlook)</option>
        <option value="custom">Mapbox Classic</option>
        <option value="osm">OpenStreetMap</option>
        <option value="opentopo">OpenTopoMap</option>
        <option value="esri">Esri World Imagery</option>
        <option value="maptiler-streets">MapTiler Streets</option>
        <option value="maptiler-outdoor">MapTiler Outdoor</option>
        <option value="maptiler-dark">MapTiler Dark</option>
        <option value="maptiler-light">MapTiler Light</option>
      </select><span class="tooltip">Choose map background</span></label>
      <label>3D Mode: <input type="checkbox" id="3d-mode-toggle" onchange="toggle3DMode()"><span class="tooltip">Switch to 3D view</span></label>
      <label id="terrain-exaggeration-slider-label" class="hidden">Terrain Exaggeration: <input type="range" id="terrain-exaggeration-slider" min="0" max="20" value="12" onchange="updateTerrainExaggeration()"><span class="tooltip">Adjust terrain height in 3D mode</span></label>
      <label>Number Resolution: <input type="range" id="density-slider" min="1" max="100" value="50" onchange="updateOverlay(currentFiltered)"><span class="tooltip">Adjust overlay grid size</span></label>
      <label>Heatmap Blur: <input type="range" id="blur-slider" min="1" max="50" value="30" onchange="updateHeatmap(currentFiltered)"><span class="tooltip">Adjust heatmap spread</span></label>
      <label id="heatmap-frequency-slider-label">3D Resolution: <input type="range" id="heatmap-frequency-slider" min="10" max="1500" value="300" onchange="updateHeatmap(currentFiltered)"><span class="tooltip">3D heatmap detail</span></label>
      <label id="heatmap-height-slider-label">3D Tower Height: <input type="range" id="heatmap-height-slider" min="1000" max="50000" value="10000" onchange="updateHeatmap(currentFiltered)"><span class="tooltip">3D heatmap height</span></label>
    </div>
    <div class="section">
      <h4>Automation</h4>
      <label>Auto-refresh: <select id="refresh-interval" onchange="setRefreshInterval()">
        <option value="0">Off</option>
        <option value="0.5">30 seconds</option>
        <option value="1" selected>1 minute</option>
        <option value="5">5 minutes</option>
        <option value="10">10 minutes</option>
      </select><span class="tooltip">Set data refresh interval</span></label>
      <label>Auto-set Latest: <input type="checkbox" id="auto-latest" checked onchange="toggleAutoLatest()"><span class="tooltip">Keep time at latest</span></label>
      <label><button id="view-mode" onclick="toggleViewMode()">Enable All Strikes</button><span class="tooltip">Show all strikes in range</span></label>
    </div>
    <div class="section">
      <h4>Extras</h4>
      <label>Sound: <input type="checkbox" id="sound-toggle" onchange="toggleSound()"><span class="tooltip">Play thunder sound</span></label>
      <label>Nowcast: <input type="checkbox" id="nowcast-toggle" checked onchange="toggleNowcast()"><span class="tooltip">Show lightning predictions</span></label>
      <label>Nowcast Confidence: <input type="range" id="min-nowcast-confidence" min="0" max="1" step="0.01" value="0.8" onchange="is3DMode ? update3DView() : toggleNowcast()"><span class="tooltip">Minimum confidence for nowcast cones to be displayed</span></label>
    </div>
    <div class="section">
      <h4>Links</h4>
      <a href="https://handry-outlook.github.io/Convective-Outlook/lightning_strikes_chart.html" target="_blank"><button>Strikes Chart</button></a>
      <a href="https://handry-outlook.github.io/Convective-Outlook/interactive_map.html" target="_blank"><button>Radar & Forecast</button></a>
    </div>
    <div class="section">
      <h4>Expert Mode</h4>
      <label>Enable: <input type="checkbox" id="expert-mode" onchange="toggleExpertMode()"><span class="tooltip">Show advanced options</span></label>
      <div id="expert-controls">
        <label>KML Layer: <input type="checkbox" id="kml-layer-toggle" checked onchange="toggleKMLLayer()"></label>
        <label>KML File: <input type="file" id="kml-file" accept=".kml" onchange="importKML(this)"></label>
        <label>PNG Layer: <input type="checkbox" id="png-layer-toggle" checked onchange="togglePNGLayer()"></label>
        <label>PNG File: <input type="file" id="png-file" accept=".png" onchange="importPNG(this)"></label>
        <label>PNG Opacity: <input type="range" id="png-opacity-slider" min="0" max="1" step="0.1" value="0.8" onchange="updatePNGOpacity()"></label>
        <label>KML Z-Index: <input type="number" id="kml-zindex" value="1500" min="0" onchange="updateZIndex()"></label>
        <label>PNG Z-Index: <input type="number" id="png-zindex" value="1400" min="0" onchange="updateZIndex()"></label>
        <label>Lightning Z-Index: <input type="number" id="lightning-zindex" value="1000" min="0" onchange="updateZIndex()"></label>
        <label>Heatmap Z-Index: <input type="number" id="heatmap-zindex" value="70" min="0" onchange="updateZIndex()"></label>
        <label>Numbers Z-Index: <input type="number" id="numbers-zindex" value="1200" min="0" onchange="updateZIndex()"></label>
      </div>
    </div>
  </div>
  <div id="map"></div>
  <div id="map-3d"></div>
  <div class="time-slider-container">
    <label><input type="range" id="history-slider" class="slider" min="0" max="2880" value="2880" oninput="updateHistory()"> <span id="history-label">Now</span></label>
    <p id="history-time"></p>
    <div class="animator">
      <button onclick="playAnimation()">▶️ Play</button>
      <button onclick="stopAnimation()">⏹️ Stop</button>
      <label>Speed: <input type="range" id="speed-slider" min="1" max="100" step="1" value="50" oninput="updateSpeedTextbox()"></label>
      <label>Min/Sec: <input type="number" id="playback-minutes" min="0.01" step="0.01" value="50" oninput="updateSpeedSlider()"></label>
    </div>
    <p id="time-range" class="status-info"></p>
    <div class="status-info-container">
      <p id="last-update" class="status-info"></p>
      <p id="current-time" class="status-info"></p>
    </div>
  </div>
  <button id="settings-button" onclick="toggleControls()">⚙️</button>
  <div id="3d-draw-modal" class="modal" style="display: none;">
  <p>Drawing is only available in 2D mode. Would you like to switch to 2D mode to draw?</p>
  <button onclick="switchTo2DForDrawing()">Switch to 2D</button>
  <button onclick="close3DDrawModal()">Cancel</button>
</div>
  <div id="tutorial-modal" class="modal" style="display: none;">
    <h3>Tutorial</h3>
    <div id="normal-tutorial">
      <h4>Normal Mode</h4>
      <p>Use the "Start Time" and "End Time" inputs to filter lightning strikes by time, then click "Apply Filter". Toggle layers like "Lightning Layer", "Heatmap", and "Overlay Numbers" to visualize data. Use the slider below the map to view strikes within the "Lightning Lifespan" (e.g., 3 hours) from the selected time, up to the "Max History" hours back (left) to now (right). Adjust the "Lightning Lifespan" to control the time window of displayed strikes. Click "Play" to animate strikes from oldest to newest, adjust speed with the slider or "Minutes per Second" input (e.g., 1 = 1 minute of strikes per second), and stop to pause.</p>
      <p>Enable "Sound" to play a thunder sound for each new strike within the map's view.</p>
      <p>Enable "3D Mode" to view the map as a 3D globe with terrain using Mapbox's Handry Outlook style, occupying the full map container. In 3D mode, the "Heatmap" checkbox controls a 2D heatmap, and the "3D Heatmap" checkbox enables a 3D terrain-like surface. Both can be enabled simultaneously. Adjust "3D Heatmap Resolution" and "3D Heatmap Tower Height" sliders (visible only in 3D mode) for the 3D heatmap, and "Heatmap Blur" for the 2D heatmap. Overlay numbers, KML, and PNG layers are also supported in 3D mode.</p>
      <p>Enable "Nowcast" to display predicted lightning movement based on recent strike clusters. Nowcast shows circles at cluster centers and cones indicating the predicted direction of movement, colored by confidence (purple for very high, red for high, orange for moderate, yellow for low). This feature works in both 2D and 3D modes and updates dynamically when applying filters.</p>
    </div>
    <div id="expert-tutorial">
      <h4>Expert Mode</h4>
      <p>Enable "Expert Mode" to access KML and PNG uploads. Upload a KML file to overlay risk zones, or a PNG file for custom imagery. Toggle these layers on/off and adjust settings like "PNG Opacity" or layer z-indices to customize their display order in both 2D and 3D modes.</p>
      <p>For KML files, ensure polygon names match risk levels: 'Low risk', 'Slight risk', 'Enhanced risk', 'Moderate risk', 'High risk' for correct colors.</p>
      <p>For PNG files, the filename should include the region name (e.g., 'England', 'Wales') to set image bounds.</p>
    </div>
    <button onclick="closeTutorial()">Close</button>
  </div>
  <div id="modal" class="modal" style="display: none;">
    <p>Do you want to adjust the time filter based on the file's timestamp?</p>
    <button onclick="confirmAutoTimeFilter(true)">Yes</button>
    <button onclick="confirmAutoTimeFilter(false)">No</button>
  </div>
  <div id="overlay" class="overlay" style="display: none;"></div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/togeojson@0.16.0"></script>
  <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.0.1/maptiler-sdk.umd.min.js"></script>
  <script src="https://cdn.maptiler.com/leaflet-maptilersdk/v4.0.2/leaflet-maptilersdk.umd.min.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.js"></script>
  <script>
    const mapboxAccessToken = 'pk.eyJ1IjoiaGFuZHJ5LW91dGxvb2siLCJhIjoiY2xrbnNrbmVlMXo0NDNqa2d3MTY2NW90bCJ9.AJbccNwtKvKA8il3JkE3PA';
    const maptilerApiKey = 'd6FiSbcpDtzJ4g4e0oD4';

    const risk_colors = {
  'Low risk': '#5aac91',
  'Slight risk': '#ffff00',
  'Enhanced risk': '#ffa500',
  'Moderate risk': '#ff0000',
  'High risk': '#800080',
  'Severe risk': '#000000' // Added Severe risk with black color
};

    const region_bounds = {
      "England": [[47.7, -21.1], [57.075, 9.95]],
      "Wales": [[51.4, -5.3], [53.4, -2.8]],
      "Scotland": [[54.6, -7.5], [60.8, -0.7]],
      "Northern Ireland": [[49.98, -21.65], [56.25, 1.075]],
      "Ireland and Northern Ireland": [[49.98, -21.65], [56.25, 1.075]],
      "UK": [[47.8, -32.6], [61.3, 15.8]]
    };
    let is3DMode = false;
    let map, map3D;
    let baseLayers = {
      mapbox: L.tileLayer('https://api.mapbox.com/styles/v1/handry-outlook/cm9457ty1009d01sk37353ux2/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 512,
        zoomOffset: -1,
        attribution: '© Mapbox © OpenStreetMap',
        maxZoom: 18
      }),
      custom: L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v12/tiles/256/{z}/{x}/{y}@2x?access_token=' + mapboxAccessToken, {
        tileSize: 512,
        zoomOffset: -1,
        attribution: '© Mapbox © OpenStreetMap',
        maxZoom: 18
      }),
      osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap'
      }),
      opentopo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 17,
        attribution: 'Map data: © OpenTopoMap (CC-BY-SA)'
      }),
      esri: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Tiles © Esri'
      }),
      'maptiler-streets': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.STREETS,
        attribution: '© MapTiler © OpenStreetMap contributors'
      }),
      'maptiler-outdoor': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.OUTDOOR,
        attribution: '© MapTiler © OpenStreetMap contributors'
      }),
      'maptiler-dark': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.DATAVIZ.DARK,
        attribution: '© MapTiler © OpenStreetMap contributors'
      }),
      'maptiler-light': L.maptiler.maptilerLayer({
        apiKey: maptilerApiKey,
        style: L.maptiler.MapStyle.DATAVIZ.LIGHT,
        attribution: '© MapTiler © OpenStreetMap contributors'
      })
    };

    map = L.map('map', { layers: [baseLayers.mapbox], zoomControl: false }).setView([53.5, -4.5], 6);

   map3D = new mapboxgl.Map({
  container: 'map-3d',
  style: 'mapbox://styles/handry-outlook/cm9457ty1009d01sk37353ux2',
  center: [-4.5, 53.5],
  zoom: 5,
  projection: 'globe',
  accessToken: mapboxAccessToken
});

map3D.on('load', () => {
  map3D.addSource('mapbox-dem', {
    'type': 'raster-dem',
    'url': 'mapbox://mapbox.terrain-rgb',
    'tileSize': 512,
    'maxzoom': 14
  });
  map3D.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 12 });
  map3D.resize(); // Ensure 3D map is sized correctly
});
map.invalidateSize(); // Ensure 2D map is sized correctly

     const timeSliderContainer = document.querySelector('.time-slider-container');
 const logo = document.createElement('img');
logo.src = 'https://raw.githubusercontent.com/Handry-Outlook/Convective-Outlook/main/Handry_outlook_icon_pride_small.png';
logo.className = 'logo';
logo.style.width = '80px';
logo.style.pointerEvents = 'none';

// Append logo to the map container for mobile positioning
const mapDiv = document.getElementById('map');
mapDiv.appendChild(logo);


    const legendControl = L.control({ position: 'topright' });
legendControl.onAdd = function (map) {
  const div = L.DomUtil.create('div', 'legend');
  div.innerHTML = '<h4>Legend</h4>';
  div.style.display = 'none'; // Initially hidden
  return div;
};
legendControl.addTo(map);

    let strikeData = [];
    let strikeLayer = L.layerGroup().addTo(map);
    let heatmapLayer = null;
    let numberOverlay = null;
    let numberOverlay3D = [];
    let animationInterval = null;
    let currentFiltered = [];
    let animationStart, animationEnd;
    let kmlLayer = null;
    let kmlGeoJSON = null;
    let pngLayer = null;
    let pngImage = null;
    let pngBounds = null;
    let isPlaying = false;
    let strikeCircles = [];
    let pendingFile = null;
    let pendingFileType = null;
    let isFullScreen = false;
    let refreshTimer = null;
    let lastUpdateTime = null;
    let isAdjustingHistory = false;
    let lastFilterMode = 'slider';
    let customFilterStart = null;
    let customFilterEnd = null;
    let showAllStrikes = false;
    let strikeLayer3D = [];
    let heatmapLayer3D = null;
    let lastRenderedStrikes = new Set();
    let thunderAudio = new Audio('https://handry-outlook.github.io/Lightning-Strike-Visualiser-/mouse-click-117076-%5BAudioTrimmer.com%5D.mp3');
    thunderAudio.preload = 'auto';
    let soundEnabled = false;
    let lightningEffectEnabled = false;
    let lastSoundTime = 0;
    const SOUND_COOLDOWN = 50;
    let nowcastLayer = L.layerGroup();
    let nowcastLayer3D = [];
    let currentNowcasts = [];
    let minNowcastConfidence = 0.8;
    let userLocationMarker = null;
    let isLegendVisible = false; // Legend is initially disabled
   
  let drawnItems = L.featureGroup().addTo(map);
  let drawControl;
  let drawControl3D;
  let drawnItems3D = [];
  let isDrawingEnabled = false;
  let editingLayerId = null;
  

  // Initialize Leaflet.draw for 2D mode
  function initializeDrawControl() {
    drawControl = new L.Control.Draw({
      draw: {
        polygon: {
          allowIntersection: false,
          showArea: true,
          drawError: { color: '#b00b00', timeout: 1000 },
          shapeOptions: { color: risk_colors['Low risk'], weight: 2, opacity: 0.8, fillOpacity: 0.3 }
        },
        polyline: false,
        circle: false,
        rectangle: false,
        marker: false,
        circlemarker: false
      },
      edit: {
        featureGroup: drawnItems,
        remove: true
      }
    });
    map.addControl(drawControl);

    map.on(L.Draw.Event.CREATED, function (e) {
      const layer = e.layer;
      const riskLevel = document.getElementById('risk-level-select')?.value || 'Low risk';
      layer.feature = { type: 'Feature', properties: { name: riskLevel, source: 'leaflet' } };
      layer.setStyle({
        color: risk_colors[riskLevel],
        fillColor: risk_colors[riskLevel] === risk_colors['Severe risk'] ? 'transparent' : risk_colors[riskLevel],
        fillOpacity: parseFloat(document.getElementById('polygon-opacity')?.value || 0.3),
        weight: parseFloat(document.getElementById('polygon-weight')?.value || 2)
      });
      layer._leaflet_id = layer._leaflet_id || `leaflet-${Date.now()}`;
      drawnItems.addLayer(layer);
      addPolygonPopup(layer);
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      console.log('Created 2D polygon:', layer._leaflet_id, layer.toGeoJSON());
    });

    map.on(L.Draw.Event.EDITED, function (e) {
      e.layers.eachLayer(layer => {
        if (layer && is3DMode) syncPolygonsTo3D();
        updatePolygonPopup(layer);
      });
      updateLegend();
      if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
        drawControl._toolbars.edit._modes.edit.handler.disable();
      }
      editingLayerId = null;
    });

    map.on(L.Draw.Event.DELETED, function (e) {
      if (is3DMode) syncPolygonsTo3D();
      updateLegend();
      editingLayerId = null;
    });
  }
  function initializeDrawControl3D() {
  // No drawing in 3D mode
}
  // Initialize Mapbox GL Draw for 3D mode
  function initializeDrawControl3D2() {
    drawControl3D = new MapboxDraw({
      displayControlsDefault: false,
      controls: {
        polygon: true,
        trash: true
      },
      styles: [
        {
          id: 'gl-draw-polygon-fill-inactive',
          type: 'fill',
          paint: {
            'fill-color': '#5aac91',
            'fill-opacity': 0.3
          }
        },
        {
          id: 'gl-draw-polygon-stroke-inactive',
          type: 'line',
          paint: {
            'line-color': '#5aac91',
            'line-width': 2,
            
          }
        },
        {
          id: 'gl-draw-polygon-fill-active',
          type: 'fill',
          paint: {
            'fill-color': '#5aac91',
            'fill-opacity': 0.5
          }
        },
        {
          id: 'gl-draw-polygon-stroke-active',
          type: 'line',
          paint: {
            'line-color': '#5aac91',
            'line-width': 3
          }
        },
        {
          id: 'gl-draw-vertex-inactive',
          type: 'circle',
          paint: {
            'circle-radius': 5,
            'circle-color': '#fff',
            'circle-stroke-color': '#5aac91',
            'circle-stroke-width': 2,
            'circle-opacity': 0, // Set to 0 to hide inactive vertices
            'circle-stroke-opacity': 0
          }
        },
        {
          id: 'gl-draw-vertex-active',
          type: 'circle',
          paint: {
            'circle-radius': 7,
            'circle-color': '#5aac91'
          }
        }
      ]
    });
    map3D.addControl(drawControl3D, 'top-right');

    map3D.on('draw.create', function (e) {
      const geojson = e.features[0];
      const riskLevel = document.getElementById('risk-level-select')?.value || 'Low risk';
      geojson.properties = { name: riskLevel, source: 'mapbox' };
      const isSevere = riskLevel === 'Severe risk';
      const layerId = `drawn-polygon-${geojson.id || Date.now()}`;
      map3D.addSource(layerId, { type: 'geojson', data: geojson });
      map3D.addLayer({
        id: layerId,
        type: 'fill',
        source: layerId,
        paint: {
          'fill-color': risk_colors[riskLevel],
          'fill-opacity': isSevere ? 0 : parseFloat(document.getElementById('polygon-opacity')?.value || 0.3)
        }
      });
      map3D.addLayer({
        id: `${layerId}-outline`,
        type: 'line',
        source: layerId,
        paint: {
          'line-color': risk_colors[riskLevel],
          'line-width': parseFloat(document.getElementById('polygon-weight')?.value || 2),
          'line-opacity': 1
        }
      });
      drawnItems3D.push({
        id: layerId,
        outlineId: `${layerId}-outline`,
        source: layerId
      });
      const leafletLayer = L.geoJSON(geojson, {
        style: {
          color: risk_colors[riskLevel],
          fillColor: isSevere ? 'transparent' : risk_colors[riskLevel],
          fillOpacity: parseFloat(document.getElementById('polygon-opacity')?.value || 0.3),
          weight: parseFloat(document.getElementById('polygon-weight')?.value || 2)
        }
      });
      leafletLayer.feature = geojson;
      leafletLayer._leaflet_id = layerId;
      drawnItems.addLayer(leafletLayer);
      addPolygonPopup(leafletLayer);
      updateLegend();
      console.log('Created 3D polygon:', layerId, geojson);
    });

    map3D.on('draw.update', function (e) {
      const geojson = e.features[0];
      const layerId = `drawn-polygon-${geojson.id || Date.now()}`;
      const leafletLayer = drawnItems.getLayer(layerId);
      if (leafletLayer) {
        leafletLayer.clearLayers();
        leafletLayer.addData(geojson);
        updatePolygonPopup(leafletLayer);
        if (is3DMode) syncPolygonsTo3D();
        updateLegend();
        console.log('Updated 3D polygon:', layerId, geojson);
      }
    });

    map3D.on('draw.delete', function (e) {
      e.features.forEach(feature => {
        const layerId = `drawn-polygon-${feature.id || Date.now()}`;
        const leafletLayer = drawnItems.getLayer(layerId);
        if (leafletLayer) {
          drawnItems.removeLayer(leafletLayer);
        }
        const item = drawnItems3D.find(d => d.id === layerId);
        if (item) {
          if (map3D.getLayer(item.id)) map3D.removeLayer(item.id);
          if (map3D.getLayer(item.outlineId)) map3D.removeLayer(item.outlineId);
          if (map3D.getSource(item.source)) map3D.removeSource(item.source);
          drawnItems3D = drawnItems3D.filter(d => d.id !== layerId);
        }
      });
      updateLegend();
      editingLayerId = null;
      console.log('Deleted 3D polygon(s)');
    });

    // Handle clicks on 3D map polygons to open Leaflet popups
    map3D.on('click', function (e) {
  if (isDrawingEnabled && drawControl3D.getMode() === 'draw_polygon') return; // Ignore clicks during active drawing
  const features = map3D.queryRenderedFeatures(e.point, {
    layers: drawnItems3D.map(item => item.id)
  });
  if (features.length > 0) {
    const layerId = features[0].layer.id;
    const leafletLayer = drawnItems.getLayer(layerId);
    if (leafletLayer && leafletLayer.getPopup()) {
      console.log('Clicked 3D polygon:', layerId);
      // Temporarily enable 2D map for popup rendering
      map.getContainer().style.opacity = '0';
      map.getContainer().style.height = '100%';
      map.getContainer().style.overflow = 'visible';
      leafletLayer.openPopup([e.lngLat.lat, e.lngLat.lng]);
      // Revert 2D map after popup interaction
      setTimeout(() => {
        map.getContainer().style.opacity = '0';
        map.getContainer().style.height = '0';
        map.getContainer().style.overflow = 'hidden';
      }, 100);
    } else {
      console.warn('No Leaflet layer or popup found for:', layerId);
    }
    // Prevent accidental edit mode activation
    if (drawControl3D.getMode() !== 'draw_polygon') {
      drawControl3D.changeMode('simple_select');
    }
  }
});

  }

  // Toggle 3D mode
  function toggle3DMode() {
  is3DMode = !is3DMode;
  const button = document.querySelector('#top-bar button[onclick="toggle3DMode()"]') || document.querySelector('#control-panel button[onclick="toggle3DMode()"]');
  if (button) {
    button.textContent = is3DMode ? 'Switch to 2D' : 'Switch to 3D';
  }
  document.body.classList.toggle('three-d-mode', is3DMode);
  if (is3DMode) {
    map3D.resize();
    syncPolygonsTo3D();
    if (isDrawingEnabled) {
      isDrawingEnabled = false;
      const drawButton = document.querySelector('#top-bar button[onclick="toggleDrawing()"]') || document.querySelector('#control-panel button[onclick="toggleDrawing()"]');
      if (drawButton) {
        drawButton.textContent = 'Enable Drawing';
      }
      console.log('Drawing disabled when switching to 3D mode');
    }
  } else {
    map.getContainer().style.display = 'block';
    map.getContainer().style.opacity = '1';
    map.getContainer().style.height = 'auto';
    map.getContainer().style.overflow = 'visible';
    clear3DPolygons();
    map3D.getContainer().style.opacity = '0';
  }
  updateLegend();
  console.log('Toggled to', is3DMode ? '3D' : '2D', 'mode, synced polygons');
}

  // Toggle drawing mode
 function toggleDrawing() {
  if (is3DMode) {
    // Show modal prompting to switch to 2D mode
    document.getElementById('3d-draw-modal').style.display = 'block';
    document.getElementById('overlay').style.display = 'block';
    return;
  }

  isDrawingEnabled = !isDrawingEnabled;
  const button = document.querySelector('#top-bar button[onclick="toggleDrawing()"]') || document.querySelector('#control-panel button[onclick="toggleDrawing()"]');
  if (button) {
    button.textContent = isDrawingEnabled ? 'Disable Drawing' : 'Enable Drawing';
  }
  if (isDrawingEnabled) {
    drawControl._toolbars.draw._modes.polygon.handler.enable();
  } else {
    drawControl._toolbars.draw._modes.polygon.handler.disable();
    // Disable any active edit mode to prevent vertex interaction
    if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
      drawControl._toolbars.edit._modes.edit.handler.disable();
    }
    editingLayerId = null;
  }
  console.log('Drawing', isDrawingEnabled ? 'enabled' : 'disabled', 'in 2D mode');
}
function switchTo2DForDrawing() {
  is3DMode = false;
  document.body.classList.remove('three-d-mode');
  map.getContainer().style.display = 'block';
  map.getContainer().style.opacity = '1';
  map.getContainer().style.height = 'auto';
  map.getContainer().style.overflow = 'visible';
  map3D.getContainer().style.opacity = '0';
  clear3DPolygons();
  const button = document.querySelector('#top-bar button[onclick="toggle3DMode()"]') || document.querySelector('#control-panel button[onclick="toggle3DMode()"]');
  if (button) {
    button.textContent = 'Switch to 3D';
  }
  close3DDrawModal();
  toggleDrawing(); // Enable drawing after switching to 2D
  console.log('Switched to 2D mode for drawing');
}

function close3DDrawModal() {
  document.getElementById('3d-draw-modal').style.display = 'none';
  document.getElementById('overlay').style.display = 'none';
}
  // Sync 2D polygons to 3D
  function syncPolygonsTo3D() {
    clear3DPolygons();
    console.log('Syncing polygons to 3D, drawnItems layers:', drawnItems.getLayers().length);
    drawnItems.eachLayer(layer => {
      if (!layer || !document.getElementById('drawn-polygons-toggle')?.checked) {
        console.log('Skipping layer:', layer?._leaflet_id, 'toggle:', document.getElementById('drawn-polygons-toggle')?.checked);
        return;
      }
      const geojson = layer.toGeoJSON();
      geojson.properties = { 
        name: layer.feature?.properties?.name || 'Low risk', 
        source: layer.feature?.properties?.source || 'leaflet' 
      };
      const isSevere = geojson.properties.name === 'Severe risk';
      const layerId = layer._leaflet_id || `drawn-polygon-${Date.now()}`;
      if (!layer._leaflet_id) {
        layer._leaflet_id = layerId;
      }
      console.log('Syncing layer:', layerId, 'GeoJSON:', geojson);
      try {
        map3D.addSource(layerId, { type: 'geojson', data: geojson });
        map3D.addLayer({
          id: layerId,
          type: 'fill',
          source: layerId,
          paint: {
            'fill-color': layer.options.color || '#5aac91',
            'fill-opacity': isSevere ? 0 : (layer.options.fillOpacity || 0.3)
          }
        });
        map3D.addLayer({
          id: `${layerId}-outline`,
          type: 'line',
          source: layerId,
          paint: {
            'line-color': layer.options.color || '#5aac91',
            'line-width': layer.options.weight || 2,
            'line-opacity': 1
          }
        });
        drawnItems3D.push({
          id: layerId,
          outlineId: `${layerId}-outline`,
          source: layerId
        });
      } catch (error) {
        console.error('Error syncing layer:', layerId, error);
      }
    });
    map3D.resize();
    console.log('Synced', drawnItems3D.length, 'polygons to 3D');
  }

  // Clear 3D polygons
  function clear3DPolygons() {
    console.log('Clearing 3D polygons:', drawnItems3D.length);
    drawnItems3D.forEach(item => {
      if (map3D.getLayer(item.id)) map3D.removeLayer(item.id);
      if (map3D.getLayer(item.outlineId)) map3D.removeLayer(item.outlineId);
      if (map3D.getSource(item.source)) map3D.removeSource(item.source);
    });
    drawnItems3D = [];
  }

  // Add or update popup for polygon customization
  function addPolygonPopup(layer) {
    if (!layer || !layer._leaflet_id) {
      console.error('Invalid layer or missing _leaflet_id:', layer);
      return;
    }
    const popupContent = document.createElement('div');
    popupContent.className = 'polygon-popup';
    const riskLevel = layer.feature?.properties?.name || 'Low risk';
    const isEditing = editingLayerId === layer._leaflet_id;
    popupContent.innerHTML = `
      <label>Risk Level:
        <select id="risk-select-${layer._leaflet_id}">
          <option value="Low risk" ${riskLevel === 'Low risk' ? 'selected' : ''}>Low risk</option>
          <option value="Slight risk" ${riskLevel === 'Slight risk' ? 'selected' : ''}>Slight risk</option>
          <option value="Enhanced risk" ${riskLevel === 'Enhanced risk' ? 'selected' : ''}>Enhanced risk</option>
          <option value="Moderate risk" ${riskLevel === 'Moderate risk' ? 'selected' : ''}>Moderate risk</option>
          <option value="High risk" ${riskLevel === 'High risk' ? 'selected' : ''}>High risk</option>
          <option value="Severe risk" ${riskLevel === 'Severe risk' ? 'selected' : ''}>Severe risk</option>
        </select>
      </label>
      <label>Color:
        <input type="color" id="color-input-${layer._leaflet_id}" value="${layer.options.color || '#5aac91'}">
      </label>
      <button id="edit-button-${layer._leaflet_id}">${isEditing ? 'Cancel Edit' : 'Edit Shape'}</button>
      ${isEditing ? `<button id="apply-button-${layer._leaflet_id}">Apply Edit</button>` : ''}
      <button id="delete-button-${layer._leaflet_id}">Delete</button>
    `;
    const riskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
    const colorInput = popupContent.querySelector(`#color-input-${layer._leaflet_id}`);
    const editButton = popupContent.querySelector(`#edit-button-${layer._leaflet_id}`);
    const applyButton = popupContent.querySelector(`#apply-button-${layer._leaflet_id}`);
    const deleteButton = popupContent.querySelector(`#delete-button-${layer._leaflet_id}`);

    if (riskSelect) {
      riskSelect.replaceWith(riskSelect.cloneNode(true));
      const newRiskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
      newRiskSelect.onchange = () => updatePolygonRisk(newRiskSelect, layer._leaflet_id);
    }
    if (colorInput) {
      colorInput.onchange = () => updatePolygonColor(colorInput, layer._leaflet_id);
    }
    if (editButton) {
      editButton.onclick = () => {
        if (editingLayerId === layer._leaflet_id) {
          cancelPolygonEdit(layer._leaflet_id);
        } else {
          startEditPolygon(layer._leaflet_id);
        }
      };
    }
    if (applyButton) {
      applyButton.onclick = () => savePolygonEdit(layer._leaflet_id);
    }
    if (deleteButton) {
      deleteButton.onclick = () => deletePolygon(layer._leaflet_id);
    }

    layer.bindPopup(popupContent);
    console.log('Added popup for layer:', layer._leaflet_id);
  }

  // Update existing popup content without rebinding
  function updatePolygonPopup(layer) {
    if (!layer || !layer._leaflet_id || !layer.getPopup()) {
      console.error('Cannot update popup for layer:', layer);
      return;
    }
    const popupContent = layer.getPopup().getContent();
    const riskLevel = layer.feature?.properties?.name || 'Low risk';
    const isEditing = editingLayerId === layer._leaflet_id;
    popupContent.innerHTML = `
      <label>Risk Level:
        <select id="risk-select-${layer._leaflet_id}">
          <option value="Low risk" ${riskLevel === 'Low risk' ? 'selected' : ''}>Low risk</option>
          <option value="Slight risk" ${riskLevel === 'Slight risk' ? 'selected' : ''}>Slight risk</option>
          <option value="Enhanced risk" ${riskLevel === 'Enhanced risk' ? 'selected' : ''}>Enhanced risk</option>
          <option value="Moderate risk" ${riskLevel === 'Moderate risk' ? 'selected' : ''}>Moderate risk</option>
          <option value="High risk" ${riskLevel === 'High risk' ? 'selected' : ''}>High risk</option>
          <option value="Severe risk" ${riskLevel === 'Severe risk' ? 'selected' : ''}>Severe risk</option>
        </select>
      </label>
      <label>Color:
        <input type="color" id="color-input-${layer._leaflet_id}" value="${layer.options.color || '#5aac91'}">
      </label>
      <button id="edit-button-${layer._leaflet_id}">${isEditing ? 'Cancel Edit' : 'Edit Shape'}</button>
      ${isEditing ? `<button id="apply-button-${layer._leaflet_id}">Apply Edit</button>` : ''}
      <button id="delete-button-${layer._leaflet_id}">Delete</button>
    `;
    const riskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
    const colorInput = popupContent.querySelector(`#color-input-${layer._leaflet_id}`);
    const editButton = popupContent.querySelector(`#edit-button-${layer._leaflet_id}`);
    const applyButton = popupContent.querySelector(`#apply-button-${layer._leaflet_id}`);
    const deleteButton = popupContent.querySelector(`#delete-button-${layer._leaflet_id}`);

    if (riskSelect) {
      riskSelect.replaceWith(riskSelect.cloneNode(true));
      const newRiskSelect = popupContent.querySelector(`#risk-select-${layer._leaflet_id}`);
      newRiskSelect.onchange = () => updatePolygonRisk(newRiskSelect, layer._leaflet_id);
    }
    if (colorInput) {
      colorInput.onchange = () => updatePolygonColor(colorInput, layer._leaflet_id);
    }
    if (editButton) {
      editButton.onclick = () => {
        if (editingLayerId === layer._leaflet_id) {
          cancelPolygonEdit(layer._leaflet_id);
        } else {
          startEditPolygon(layer._leaflet_id);
        }
      };
    }
    if (applyButton) {
      applyButton.onclick = () => savePolygonEdit(layer._leaflet_id);
    }
    if (deleteButton) {
      deleteButton.onclick = () => deletePolygon(layer._leaflet_id);
    }
    console.log('Updated popup for layer:', layer._leaflet_id);
  }

  // Update polygon risk level
  function updatePolygonRisk(select, layerId) {
    const layer = drawnItems.getLayer(layerId);
    if (!layer) {
      console.error(`Layer with ID ${layerId} not found`);
      return;
    }
    const risk = select.value;
    layer.feature = layer.feature || { type: 'Feature', properties: {} };
    layer.feature.properties.name = risk;
    const isSevere = risk === 'Severe risk';
    layer.setStyle({
      color: risk_colors[risk],
      fillColor: isSevere ? 'transparent' : risk_colors[risk],
      fillOpacity: parseFloat(document.getElementById('polygon-opacity')?.value || 0.3),
      weight: parseFloat(document.getElementById('polygon-weight')?.value || 2)
    });
    if (is3DMode) syncPolygonsTo3D();
    updateLegend();
    updatePolygonPopup(layer);
    console.log('Updated risk level for layer:', layerId, 'to', risk);
  }

  // Update polygon color
  function updatePolygonColor(input, layerId) {
    const layer = drawnItems.getLayer(layerId);
    if (!layer) {
      console.error(`Layer with ID ${layerId} not found`);
      return;
    }
    const color = input.value;
    layer.setStyle({
      color,
      fillColor: layer.feature?.properties?.name === 'Severe risk' ? 'transparent' : color
    });
    if (is3DMode) syncPolygonsTo3D();
    updateLegend();
    updatePolygonPopup(layer);
    console.log('Updated color for layer:', layerId, 'to', color);
  }

  // Start editing polygon shape
  function startEditPolygon(layerId) {
    const layer = drawnItems.getLayer(layerId);
    if (!layer) {
      console.error(`Layer with ID ${layerId} not found`);
      return;
    }
    if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
      if (drawControl3D) {
        drawControl3D.changeMode('direct_select', { featureId: layerId.replace('drawn-polygon-', '') });
        editingLayerId = layerId;
        updatePolygonPopup(layer);
        layer.openPopup();
      } else {
        console.error('3D draw control not initialized');
      }
    } else {
      if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
        drawControl._toolbars.edit._modes.edit.handler.enable();
        if (layer.editing) {
          layer.editing.enable();
        } else {
          console.warn('Layer editing not supported for this layer:', layer);
        }
        editingLayerId = layerId;
        updatePolygonPopup(layer);
        layer.openPopup();
      } else {
        console.error('Edit toolbar not initialized');
      }
    }
    console.log('Started editing layer:', layerId);
  }

  // Save edited polygon shape
  function savePolygonEdit(layerId) {
    const layer = drawnItems.getLayer(layerId);
    if (!layer) {
      console.error(`Layer with ID ${layerId} not found`);
      return;
    }
    if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
      if (drawControl3D) {
        drawControl3D.changeMode('simple_select');
        const geojson = layer.toGeoJSON();
        const sourceId = layerId;
        if (map3D.getSource(sourceId)) {
          map3D.getSource(sourceId).setData(geojson);
        }
      }
    } else {
      if (layer.editing) {
        layer.editing.disable();
      }
      if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
        drawControl._toolbars.edit._modes.edit.handler.save();
        drawControl._toolbars.edit._modes.edit.handler.disable();
      }
    }
    if (is3DMode) syncPolygonsTo3D();
    updateLegend();
    editingLayerId = null;
    updatePolygonPopup(layer);
    layer.openPopup();
    console.log('Saved edits for layer:', layerId);
  }

  // Cancel editing polygon shape
  function cancelPolygonEdit(layerId) {
    const layer = drawnItems.getLayer(layerId);
    if (!layer) {
      console.error(`Layer with ID ${layerId} not found`);
      return;
    }
    if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
      if (drawControl3D) {
        drawControl3D.changeMode('simple_select');
      }
    } else {
      if (layer.editing) {
        layer.editing.disable();
      }
      if (drawControl?._toolbars?.edit?._modes?.edit?.handler) {
        drawControl._toolbars.edit._modes.edit.handler.revertLayers();
        drawControl._toolbars.edit._modes.edit.handler.disable();
      }
    }
    if (is3DMode) syncPolygonsTo3D();
    editingLayerId = null;
    updatePolygonPopup(layer);
    layer.openPopup();
    console.log('Canceled edits for layer:', layerId);
  }

  // Delete polygon
  function deletePolygon(layerId) {
    const layer = drawnItems.getLayer(layerId);
    if (!layer) {
      console.error(`Layer with ID ${layerId} not found`);
      return;
    }
    drawnItems.removeLayer(layer);
    if (is3DMode && layer.feature?.properties?.source === 'mapbox') {
      const item = drawnItems3D.find(d => d.id === layerId);
      if (item) {
        if (map3D.getLayer(item.id)) map3D.removeLayer(item.id);
        if (map3D.getLayer(item.outlineId)) map3D.removeLayer(item.outlineId);
        if (map3D.getSource(item.source)) map3D.removeSource(item.source);
        drawnItems3D = drawnItems3D.filter(d => d.id !== layerId);
      }
    }
    if (is3DMode) syncPolygonsTo3D();
    updateLegend();
    editingLayerId = null;
    console.log('Deleted layer:', layerId);
  }

  // Update all polygons' opacity
  function updateAllPolygonsOpacity() {
    const opacity = parseFloat(document.getElementById('polygon-opacity')?.value || 0.3);
    drawnItems.eachLayer(layer => {
      if (layer) {
        layer.setStyle({ fillOpacity: layer.feature?.properties?.name === 'Severe risk' ? 0 : opacity });
      }
    });
    if (is3DMode) syncPolygonsTo3D();
    updateLegend();
    console.log('Updated opacity for all polygons:', opacity);
  }

  // Update all polygons' outline weight
  function updateAllPolygonsWeight() {
    const weight = parseFloat(document.getElementById('polygon-weight')?.value || 2);
    drawnItems.eachLayer(layer => {
      if (layer) {
        layer.setStyle({ weight });
      }
    });
    if (is3DMode) syncPolygonsTo3D();
    updateLegend();
    console.log('Updated weight for all polygons:', weight);
  }

  // Export drawn polygons to KML
  function exportToKML() {
    const kmlHeader = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
  <name>Drawn Polygons</name>`;
    let kmlBody = '';
    drawnItems.eachLayer(layer => {
      if (!layer || !layer.toGeoJSON || !layer.options?.color) return;
      const geojson = layer.toGeoJSON();
      const coordinates = geojson.geometry.coordinates[0]?.map(coord => `${coord[0]},${coord[1]},0`).join(' ') || '';
      const risk = layer.feature?.properties?.name || 'Low risk';
      kmlBody += `
        <Placemark>
          <name>${risk}</name>
          <Style>
            <LineStyle>
              <color>ff${layer.options.color.replace('#', '')}</color>
              <width>${layer.options.weight || 2}</width>
            </LineStyle>
            <PolyStyle>
              <color>${risk === 'Severe risk' ? '00' : '7f'}${layer.options.color.replace('#', '')}</color>
            </PolyStyle>
          </Style>
          <Polygon>
            <outerBoundaryIs>
              <LinearRing>
                <coordinates>${coordinates}</coordinates>
              </LinearRing>
            </outerBoundaryIs>
          </Polygon>
        </Placemark>`;
    });
    const kmlFooter = `
</Document>
</kml>`;
    const kmlContent = kmlHeader + kmlBody + kmlFooter;
    const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'drawn_polygons.kml';
    a.click();
    URL.revokeObjectURL(url);
    console.log('Exported polygons to KML');
  }







    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      const button = document.querySelector('#top-bar button[onclick="toggleDarkMode()"]');
      button.textContent = document.body.classList.contains('dark-mode') ? '☀️ Light Mode' : '🌙 Dark Mode';
      const mapStyleSelect = document.getElementById('map-style');
      const newMapStyle = document.body.classList.contains('dark-mode') ? 'maptiler-dark' : 'mapbox';
      mapStyleSelect.value = newMapStyle;
      switchBaseMap(newMapStyle);
    }

function toggleControls() {
    const controlPanel = document.getElementById('control-panel');
    controlPanel.classList.toggle('open');
  }
    function updateTerrainExaggeration() {
    if (is3DMode) {
      const exaggeration = parseFloat(document.getElementById('terrain-exaggeration-slider').value);
      map3D.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
      map3D.resize();
    }
  }
   function showUserLocation() {
    if (!navigator.geolocation) {
      alert('Geolocation is not supported by your browser.');
      return;
    }
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const { latitude, longitude } = position.coords;
        // Remove existing marker if present
        if (userLocationMarker) {
          if (is3DMode) {
            userLocationMarker.remove();
          } else {
            map.removeLayer(userLocationMarker);
          }
          userLocationMarker = null;
        }
        // Add new marker
        if (is3DMode) {
          const el = document.createElement('div');
          el.className = 'user-location-marker';
          userLocationMarker = new mapboxgl.Marker(el)
            .setLngLat([longitude, latitude])
            .addTo(map3D);
          map3D.jumpTo({ center: [longitude, latitude], zoom: 10 });
          map3D.resize();
        } else {
          userLocationMarker = L.circleMarker([latitude, longitude], {
            radius: 6,
            color: '#3b82f6',
            fillColor: '#3b82f6',
            fillOpacity: 1,
            className: 'user-location-marker'
          }).addTo(map);
          map.setView([latitude, longitude], 10);
          map.invalidateSize();
        }
      },
      (error) => {
        alert('Unable to retrieve location: ' + error.message);
      }
    );
  }
    function toggleSound() {
      soundEnabled = document.getElementById('sound-toggle').checked;
    }

    function toggleLightningEffect() {
      lightningEffectEnabled = document.getElementById('lightning-effect-toggle').checked;
    }

    function playThunderSound() {
      if (!soundEnabled) return;
      const now = Date.now();
      if (now - lastSoundTime < SOUND_COOLDOWN) return;
      thunderAudio.currentTime = 0;
      thunderAudio.play().catch(error => console.error('Error playing sound:', error));
      lastSoundTime = now;
    }

    function addLightningFlash2D(lat, lng) {
  if (!lightningEffectEnabled || !map || !map.getPanes().overlayPane) return;

  // Ensure map size is valid
  map.invalidateSize();

  // Convert [latitude, longitude] to container coordinates
  const point = map.latLngToContainerPoint([lat, lng]);
  if (!point || isNaN(point.x) || isNaN(point.y)) {
    console.warn(`Invalid container point for lat=${lat}, lng=${lng}:`, point);
    return;
  }

  // Calculate base size based on zoom level to maintain consistent appearance
  const zoom = map.getZoom();
  const baseSize = 50 * Math.pow(2, (10 - zoom) / 2); // Adjust size based on zoom

  const flash = document.createElement('div');
  flash.className = 'lightning-flash-2d';
  flash.style.width = `${baseSize}px`;
  flash.style.height = `${baseSize}px`;
  flash.style.left = `${point.x - baseSize / 2}px`; // Center the flash
  flash.style.top = `${point.y - baseSize / 2}px`; // Center the flash
  flash.style.zIndex = '1000';
  flash.style.transformOrigin = 'center'; // Ensure scaling is centered
  map.getPanes().overlayPane.appendChild(flash);
  setTimeout(() => flash.remove(), 2500);
}

function addLightningFlash3D(lng, lat) {
  if (!lightningEffectEnabled || !map3D) return;

  // Ensure map is resized
  map3D.resize();

  // Calculate size based on zoom level
  const zoom = map3D.getZoom();
  const baseSize = 50 * Math.pow(2, (10 - zoom) / 2); // Adjust size based on zoom

  const el = document.createElement('div');
  el.className = 'lightning-flash-3d';
  el.style.width = `${baseSize}px`;
  el.style.height = `${baseSize}px`;
  el.style.transform = 'translate(-50%, -50%)'; // Center the flash
  el.style.transformOrigin = 'center'; // Ensure scaling is centered
  const marker = new mapboxgl.Marker({
    element: el,
    anchor: 'center'
  })
    .setLngLat([lng, lat])
    .addTo(map3D);
  setTimeout(() => marker.remove(), 2500);
}

    function toggle3DMode() {
    is3DMode = document.getElementById('3d-mode-toggle').checked;
    const mapDiv = document.getElementById('map');
    const map3DDiv = document.getElementById('map-3d');
    mapDiv.style.display = is3DMode ? 'none' : 'block';
    map3DDiv.style.display = is3DMode ? 'block' : 'none';
    document.getElementById('heatmap-3d-toggle').parentElement.style.display = is3DMode ? 'flex' : 'none';
    document.getElementById('heatmap-frequency-slider').parentElement.style.display = is3DMode ? 'flex' : 'none';
    document.getElementById('heatmap-height-slider').parentElement.style.display = is3DMode ? 'flex' : 'none';
    document.getElementById('terrain-exaggeration-slider').parentElement.style.display = is3DMode ? 'flex' : 'none';
    
    if (userLocationMarker) {
      if (is3DMode) {
        if (map.hasLayer(userLocationMarker)) map.removeLayer(userLocationMarker);
      } else {
        if (userLocationMarker.remove) userLocationMarker.remove();
      }
      userLocationMarker = null;
    }
    
    if (is3DMode) {
      map3D.jumpTo({ center: [-4.5, 53.5], zoom: 5 });
      map3D.resize();
      update3DView();
      toggleKMLLayer();
      togglePNGLayer();
      syncPolygonsTo3D();
      updateOverlay(currentFiltered);
      toggleNowcast();
      updateLegend();
      updateTerrainExaggeration();
    } else {
      map.invalidateSize();
      map.addLayer(drawnItems);
      clear3DPolygons();
      updateHistory();
      updateLegend();
    }
  }


    function update3DView() {
  // Clear existing layers
  strikeLayer3D.forEach(marker => marker.remove());
  strikeLayer3D = [];
  if (map3D.getLayer('heatmap-3d')) map3D.removeLayer('heatmap-3d');
  if (map3D.getSource('heatmap-3d')) map3D.removeSource('heatmap-3d');
  if (map3D.getLayer('heatmap-2d')) map3D.removeLayer('heatmap-2d');
  if (map3D.getSource('heatmap-2d')) map3D.removeSource('heatmap-2d');
  if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
  if (map3D.getSource('png-source')) map3D.removeSource('png-source');
  if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
  if (map3D.getLayer('kml-layer-outline')) map3D.removeLayer('kml-layer-outline');
  if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');
  nowcastLayer3D.forEach(layer => {
    if (map3D.getLayer(layer.id)) map3D.removeLayer(layer.id);
    if (map3D.getSource(layer.source)) map3D.removeSource(layer.source);
  });
  nowcastLayer3D = [];
  map3D.resize();
  const currentBounds = map3D.getBounds();
  const newStrikes = new Set();

  // Get user-defined lifespan and slider position
  const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value) || 3;
  const slider = document.getElementById('history-slider');
  let sliderValue = parseInt(slider.value);
  const maxMinutes = (parseInt(document.getElementById('max-history-hours').value) || 48) * 60;

  // Determine time range based on filter mode
  let startTime, endTime;
  if (lastFilterMode === 'inputs' && customFilterStart && customFilterEnd) {
    const filterStart = new Date(customFilterStart);
    const filterEnd = new Date(customFilterEnd);
    if (isNaN(filterStart) || isNaN(filterEnd)) {
      console.error('Invalid custom filter dates');
      return;
    }
    const totalMinutes = (filterEnd - filterStart) / (60 * 1000);
    const sliderMax = Math.max(totalMinutes, lifespanHours * 60);
    sliderValue = Math.min(sliderValue, sliderMax);
    slider.max = sliderMax;
    slider.min = 0;
    slider.value = sliderValue;
    endTime = new Date(filterStart.getTime() + sliderValue * 60 * 1000);
    startTime = new Date(endTime.getTime() - lifespanHours * 3600 * 1000);
  } else {
    const now = new Date();
    sliderValue = sliderValue || maxMinutes;
    slider.max = maxMinutes;
    slider.min = 0;
    endTime = new Date(now.getTime() - (maxMinutes - sliderValue) * 60 * 1000);
    startTime = new Date(endTime.getTime() - lifespanHours * 3600 * 1000);
  }

  // Update animation times
  animationStart = startTime;
  animationEnd = endTime;

  // Filter strikes within the lifespan
  currentFiltered = strikeData.filter(s => {
    if (showAllStrikes) {
      return s.time >= new Date(endTime.getTime() - maxMinutes * 60 * 1000) && s.time <= endTime;
    }
    return s.time >= startTime && s.time <= endTime;
  });

  // Add PNG layer
  if (document.getElementById('png-layer-toggle').checked && pngImage && pngBounds) {
    map3D.addSource('png-source', {
      type: 'image',
      url: pngImage,
      coordinates: [
        [pngBounds[0][1], pngBounds[1][0]],
        [pngBounds[1][1], pngBounds[1][0]],
        [pngBounds[1][1], pngBounds[0][0]],
        [pngBounds[0][1], pngBounds[0][0]]
      ]
    });
    map3D.addLayer({
      id: 'png-layer',
      type: 'raster',
      source: 'png-source',
      paint: {
        'raster-opacity': parseFloat(document.getElementById('png-opacity-slider').value)
      }
    });
  }

  // Add KML layer
  if (document.getElementById('kml-layer-toggle').checked && kmlGeoJSON) {
    map3D.addSource('kml-source', { type: 'geojson', data: kmlGeoJSON });
    map3D.addLayer({
      id: 'kml-layer',
      type: 'fill',
      source: 'kml-source',
      paint: {
        'fill-color': [
          'match',
          ['get', 'name'],
          'Low risk', risk_colors['Low risk'],
          'Slight risk', risk_colors['Slight risk'],
          'Enhanced risk', risk_colors['Enhanced risk'],
          'Moderate risk', risk_colors['Moderate risk'],
          'High risk', risk_colors['High risk'],
          'transparent'
        ],
        'fill-opacity': [
          'match',
          ['get', 'name'],
          'Low risk', 0.3,
          'Slight risk', 0.3,
          'Enhanced risk', 0.3,
          'Moderate risk', 0.3,
          'High risk', 0.3,
          0
        ]
      }
    });
    map3D.addLayer({
      id: 'kml-layer-outline',
      type: 'line',
      source: 'kml-source',
      paint: {
        'line-color': [
          'match',
          ['get', 'name'],
          'Low risk', risk_colors['Low risk'],
          'Slight risk', risk_colors['Slight risk'],
          'Enhanced risk', risk_colors['Enhanced risk'],
          'Moderate risk', risk_colors['Moderate risk'],
          'High risk', risk_colors['High risk'],
          risk_colors['Severe risk']
        ],
        'line-width': 2,
        'line-opacity': 1
      }
    });
  }

  // Add nowcast layers
  minNowcastConfidence = parseFloat(document.getElementById('min-nowcast-confidence').value);
  if (document.getElementById('nowcast-toggle').checked) {
    currentNowcasts = calculateLightningNowcast(currentFiltered);
    currentNowcasts.forEach((cluster, index) => {
      if (cluster.confidenceScore >= minNowcastConfidence) {
        const confidenceColor = cluster.confidenceScore > 0.9 ? 'purple' :
                                cluster.confidenceScore > 0.8 ? 'red' :
                                cluster.confidenceScore > 0.7 ? 'orange' : 'yellow';
        const radiusKm = cluster.confidenceScore * 5 + 5;
        const coneRadiusKm = cluster.confidenceScore * 30 + 30;
        const radiusDeg = radiusKm / 111;

        // Add nowcast circle
        map3D.addSource(`nowcast-circle-${index}`, {
          type: 'geojson',
          data: {
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [cluster.baseLon, cluster.baseLat]
            },
            properties: { radius: radiusDeg }
          }
        });
        map3D.addLayer({
          id: `nowcast-circle-${index}`,
          type: 'circle',
          source: `nowcast-circle-${index}`,
          paint: {
            'circle-radius': [
              'interpolate',
              ['linear'],
              ['zoom'],
              5, (radiusKm * 1000) / 1000,
              10, (radiusKm * 1000) / 250
            ],
            'circle-color': confidenceColor,
            'circle-opacity': 0.5,
            'circle-stroke-color': confidenceColor,
            'circle-stroke-width': 2,
            'circle-stroke-opacity': 0.8
          }
        });
        nowcastLayer3D.push({ id: `nowcast-circle-${index}`, source: `nowcast-circle-${index}` });

        // Add nowcast cone
        const cone = turf.sector(
          [cluster.baseLon, cluster.baseLat],
          coneRadiusKm,
          cluster.directionDeg - 15,
          cluster.directionDeg + 15,
          { units: 'kilometers' }
        );
        map3D.addSource(`nowcast-cone-${index}`, {
          type: 'geojson',
          data: cone
        });
        map3D.addLayer({
          id: `nowcast-cone-${index}`,
          type: 'fill',
          source: `nowcast-cone-${index}`,
          paint: {
            'fill-color': confidenceColor,
            'fill-opacity': 0.5
          }
        });
        nowcastLayer3D.push({ id: `nowcast-cone-${index}`, source: `nowcast-cone-${index}` });
      }
    });
  }

  // Add lightning layer
  if (document.getElementById('lightning-layer-toggle').checked) {
    currentFiltered.forEach(s => {
      const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
      newStrikes.add(strikeKey);
      const isNewStrike = !lastRenderedStrikes.has(strikeKey);
      const inBounds = currentBounds.contains([s.coordinates[0], s.coordinates[1]]);
      const ageFraction = (endTime - s.time) / (lifespanHours * 3600 * 1000);

      const el = document.createElement('div');
      el.className = 'marker';
      el.style.backgroundColor = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
      el.style.width = '10px';
      el.style.height = '10px';
      el.style.borderRadius = '50%';
      const marker = new mapboxgl.Marker(el)
        .setLngLat([s.coordinates[0], s.coordinates[1]])
        .setPopup(new mapboxgl.Popup().setText(s.time.toISOString()))
        .addTo(map3D);
      strikeLayer3D.push(marker);
      if (isNewStrike && inBounds) {
        playThunderSound();
        addLightningFlash3D(s.coordinates[0], s.coordinates[1]);
      }
    });
  }

  lastRenderedStrikes = newStrikes;

  // Render 2D and 3D heatmaps
  const heatmap2DEnabled = document.getElementById('heatmap-toggle').checked;
  const heatmap3DEnabled = document.getElementById('heatmap-3d-toggle').checked;
  const blur = parseInt(document.getElementById('blur-slider').value);

  if (heatmap2DEnabled) {
    const heatmapData = {
      type: 'FeatureCollection',
      features: currentFiltered.map(s => ({
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [s.coordinates[0], s.coordinates[1]]
        },
        properties: { intensity: 1 }
      }))
    };
    map3D.addSource('heatmap-2d', {
      type: 'geojson',
      data: heatmapData
    });
    map3D.addLayer({
      id: 'heatmap-2d',
      type: 'heatmap',
      source: 'heatmap-2d',
      paint: {
        'heatmap-weight': ['get', 'intensity'],
        'heatmap-intensity': ['interpolate', ['linear'], ['zoom'], 0, 1, 9, 3],
        'heatmap-color': [
          'interpolate',
          ['linear'],
          ['heatmap-density'],
          0, 'rgba(0, 18, 25, 0)',
          0.1, '#001219',
          0.2, '#0A9396',
          0.3, '#94D2BD',
          0.4, '#E9D8A6',
          0.5, '#c89578',
          0.6, '#EE9B00',
          0.7, '#CA6702',
          0.8, '#BB3E03',
          0.9, '#AE2012',
          1, '#9B2226'
        ],
        'heatmap-radius': ['interpolate', ['linear'], ['zoom'], 0, blur, 9, blur * 2],
        'heatmap-opacity': ['interpolate', ['linear'], ['zoom'], 7, 1, 9, 0.7]
      }
    });
  }

  if (heatmap3DEnabled) {
    const frequency = parseInt(document.getElementById('heatmap-frequency-slider').value);
    const maxHeight = parseInt(document.getElementById('heatmap-height-slider').value);
    const gridData = generateHeatmapGrid(currentFiltered, frequency);
    map3D.addSource('heatmap-3d', {
      type: 'geojson',
      data: gridData
    });
    map3D.addLayer({
      id: 'heatmap-3d',
      type: 'fill-extrusion',
      source: 'heatmap-3d',
      paint: {
        'fill-extrusion-color': [
          'interpolate',
          ['linear'],
          ['get', 'intensity'],
          0, '#001219',
          0.1, '#001219',
          0.2, '#0A9396',
          0.3, '#94D2BD',
          0.4, '#E9D8A6',
          0.5, '#c89578',
          0.6, '#EE9B00',
          0.7, '#CA6702',
          0.8, '#BB3E03',
          0.9, '#AE2012',
          1, '#9B2226'
        ],
        'fill-extrusion-height': ['*', ['get', 'intensity'], maxHeight],
        'fill-extrusion-base': 0,
        'fill-extrusion-opacity': 0.7
      }
    });
  }

  updateOverlay(currentFiltered);
  updateLegend();
}
    function generateHeatmapGrid(data, frequency) {
      const UK_BBOX = [-15, 49, 8, 61];
      const [minLng, minLat, maxLng, maxLat] = UK_BBOX;
      const latStep = (maxLat - minLat) / frequency;
      const lngStep = (maxLng - minLng) / frequency;
      const grid = [];

      for (let i = 0; i < frequency; i++) {
        for (let j = 0; j < frequency; j++) {
          const count = data.reduce((sum, s) => {
            const lat = s.coordinates[1];
            const lng = s.coordinates[0];
            const cellLatMin = minLat + i * latStep;
            const cellLatMax = cellLatMin + latStep;
            const cellLngMin = minLng + j * lngStep;
            const cellLngMax = cellLngMin + lngStep;
            return sum + (lat >= cellLatMin && lat < cellLatMax && lng >= cellLngMin && lng < cellLngMax ? 1 : 0);
          }, 0);
          if (count > 0) {
            const intensity = Math.min(count / 10, 1);
            grid.push({
              type: 'Feature',
              properties: { intensity },
              geometry: {
                type: 'Polygon',
                coordinates: [[
                  [minLng + j * lngStep, minLat + i * latStep],
                  [minLng + (j + 1) * lngStep, minLat + i * latStep],
                  [minLng + (j + 1) * lngStep, minLat + (i + 1) * latStep],
                  [minLng + j * lngStep, minLat + (i + 1) * latStep],
                  [minLng + j * lngStep, minLat + i * latStep]
                ]]
              }
            });
          }
        }
      }

      return {
        type: 'FeatureCollection',
        features: grid
      };
    }

    function toggleExpertMode() {
  const expertControls = document.getElementById('expert-controls');
  const isExpertMode = document.getElementById('expert-mode').checked;
  expertControls.style.display = isExpertMode ? 'grid' : 'none';
  if (isExpertMode) {
    // Add KML and PNG layers if they exist and checkboxes are checked
    toggleKMLLayer();
    togglePNGLayer();
  } else {
    // Remove KML and PNG layers when Expert Mode is disabled
    if (kmlLayer && map.hasLayer(kmlLayer)) map.removeLayer(kmlLayer);
    if (pngLayer && map.hasLayer(pngLayer)) map.removeLayer(pngLayer);
    if (is3DMode) {
      if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
      if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');
      if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
      if (map3D.getSource('png-source')) map3D.removeSource('png-source');
    }
  }
  updateZIndex();
  updateLegend();
}

    function showTutorial() {
      document.getElementById('tutorial-modal').style.display = 'block';
      document.getElementById('overlay').style.display = 'block';
    }

    function closeTutorial() {
      document.getElementById('tutorial-modal').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
    }

    function updateHistorySliderMax() {
      if (lastFilterMode === 'slider') {
        const maxHours = parseInt(document.getElementById('max-history-hours').value) || 48;
        document.getElementById('history-slider').max = maxHours * 60;
        document.getElementById('history-slider').value = maxHours * 60;
        updateHistory();
      }
    }

    function formatTimeAgo(minutesBack) {
      if (minutesBack === 0) return 'Now';
      const hours = Math.floor(minutesBack / 60);
      const minutes = minutesBack % 60;
      let result = '';
      if (hours > 0) result += `${hours}h `;
      if (minutes > 0 || hours === 0) result += `${minutes}m`;
      return result.trim() + ' ago';
    }

    function updateHistory() {
      isAdjustingHistory = true;
      const slider = document.getElementById('history-slider');
      const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
      let start, end, sliderMax, sliderValue, minutesBack;

      if (lastFilterMode === 'inputs' && customFilterStart && customFilterEnd) {
        const filterStart = new Date(customFilterStart);
        const filterEnd = new Date(customFilterEnd);

        if (isNaN(filterStart) || isNaN(filterEnd)) {
          console.error('Invalid custom date/time format.');
          isAdjustingHistory = false;
          return;
        }

        const totalMinutes = (filterEnd - filterStart) / (60 * 1000);
        sliderMax = Math.max(totalMinutes, lifespanHours * 60);
        sliderValue = parseInt(slider.value) || sliderMax;
        minutesBack = sliderMax - sliderValue;

        end = new Date(filterStart.getTime() + sliderValue * 60 * 1000);
        start = new Date(end.getTime() - lifespanHours * 3600 * 1000);

        slider.max = sliderMax;
        slider.min = 0;
        slider.value = sliderValue;
        if (!is3DMode) {
          map.invalidateSize();
        }
        document.getElementById('history-label').innerText = formatTimeAgo(minutesBack);
        document.getElementById('history-time').innerText = `${start.toLocaleString()} - ${end.toLocaleString()}`;
      } else {
        const maxMinutes = (parseInt(document.getElementById('max-history-hours').value) || 48) * 60;
        sliderMax = maxMinutes;
        sliderValue = parseInt(slider.value) || maxMinutes;
        minutesBack = maxMinutes - sliderValue;

        const now = new Date();
        end = new Date(now.getTime() - minutesBack * 60 * 1000);
        start = new Date(end.getTime() - lifespanHours * 3600 * 1000);

        slider.max = maxMinutes;
        slider.min = 0;
        slider.value = sliderValue;

        document.getElementById('start-time').value = start.toISOString().slice(0, 16);
        document.getElementById('end-time').value = end.toISOString().slice(0, 16);
        document.getElementById('history-label').innerText = formatTimeAgo(minutesBack);
        document.getElementById('history-time').innerText = `${start.toLocaleString()} - ${end.toLocaleString()}`;
        document.getElementById('remove-filter').style.display = 'none';
      }

      animationStart = start;
      animationEnd = end;

      strikeLayer.clearLayers();
      strikeCircles = [];
      const currentBounds = is3DMode ? map3D.getBounds() : map.getBounds();
      const newStrikes = new Set();

      currentFiltered = strikeData.filter(s => {
        if (showAllStrikes) {
          return s.time >= new Date(end.getTime() - parseInt(document.getElementById('max-history-hours').value) * 3600 * 1000) && s.time <= end;
        }
        return s.time >= start && s.time <= end;
      });

      currentFiltered.forEach(s => {
        const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
        newStrikes.add(strikeKey);
        const isNewStrike = !lastRenderedStrikes.has(strikeKey);
        const inBounds = is3DMode ? 
          currentBounds.contains([s.coordinates[0], s.coordinates[1]]) :
          currentBounds.contains([s.coordinates[1], s.coordinates[0]]);
        const ageFraction = (end - s.time) / (lifespanHours * 3600 * 1000);
        const color = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
        const circle = L.circleMarker([s.coordinates[1], s.coordinates[0]], {
          radius: 5,
          color: color,
          fillColor: color,
          fillOpacity: 0.8
        }).bindPopup(s.time.toISOString());
        strikeLayer.addLayer(circle);
        strikeCircles.push({ circle, strike: s });
        if (isNewStrike && inBounds && document.getElementById('lightning-layer-toggle').checked) {
          playThunderSound();
          if (!is3DMode) addLightningFlash2D(s.coordinates[1], s.coordinates[0]);
        }
      });

      lastRenderedStrikes = newStrikes;

      updateHeatmap(currentFiltered);
      updateOverlay(currentFiltered);
      updateNowcast(currentFiltered);
      updateZIndex();
      updateLegend();
      if (is3DMode) update3DView();

      setTimeout(() => { isAdjustingHistory = false; }, 1000);
    }

    function removeTimeFilter() {
      lastFilterMode = 'slider';
      customFilterStart = null;
      customFilterEnd = null;
      document.getElementById('remove-filter').style.display = 'none';
      document.getElementById('auto-latest').checked = true;
      toggleAutoLatest();
    }

    function setRefreshInterval() {
      if (refreshTimer) clearInterval(refreshTimer);
      const interval = parseFloat(document.getElementById('refresh-interval').value);
      if (interval > 0) {
        refreshTimer = setInterval(fetchData, interval * 60 * 1000);
      }
    }

    function toggleAutoLatest() {
      if (document.getElementById('auto-latest').checked) {
        const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
        const now = new Date();
        const start = new Date(now.getTime() - lifespanHours * 3600 * 1000);
        document.getElementById('start-time').value = start.toISOString().slice(0, 16);
        document.getElementById('end-time').value = now.toISOString().slice(0, 16);
        const maxMinutes = (parseInt(document.getElementById('max-history-hours').value) || 48) * 60;
        document.getElementById('history-slider').value = maxMinutes;
        document.getElementById('history-label').innerText = 'Now';
        lastFilterMode = 'slider';
        customFilterStart = null;
        customFilterEnd = null;
        document.getElementById('remove-filter').style.display = 'none';
        updateHistory();
      }
    }

    function updateClock() {
      const now = new Date();
      document.getElementById('current-time').innerText = `Current time: ${now.toLocaleString()}`;
    }
    setInterval(updateClock, 1000);
    updateClock();

    function parseDateFromFilename(filename) {
      const regex = /(\d{2})(\d{2})(\d{4})_(\d{2})(\d{2})__(\d{2})(\d{2})(\d{4})_(\d{2})(\d{2})|(\d{2})(\d{2})(\d{4})\s+(\d{2})(\d{2})\s+-\s+(\d{2})(\d{2})(\d{4})\s+(\d{2})(\d{2})/;
      const match = filename.match(regex);
      if (!match) return null;

      let startDate, endDate;
      if (match[1]) {
        startDate = new Date(`${match[3]}-${match[2]}-${match[1]}T${match[4]}:${match[5]}:00Z`);
        endDate = new Date(`${match[8]}-${match[7]}-${match[6]}T${match[9]}:${match[10]}:00Z`);
      } else {
        startDate = new Date(`${match[13]}-${match[12]}-${match[11]}T${match[14]}:${match[15]}:00Z`);
        endDate = new Date(`${match[18]}-${match[17]}-${match[16]}T${match[19]}:${match[20]}:00Z`);
      }

      return { startDate, endDate };
    }

    function showTimeFilterModal(file, type) {
      pendingFile = file;
      pendingFileType = type;
      const modal = document.getElementById('modal');
      const overlay = document.getElementById('overlay');
      modal.style.display = 'block';
      overlay.style.display = 'block';
    }

    function confirmAutoTimeFilter(confirm) {
      const modal = document.getElementById('modal');
      const overlay = document.getElementById('overlay');
      modal.style.display = 'none';
      overlay.style.display = 'none';

      if (!pendingFile || !pendingFileType) return;

      if (confirm && document.getElementById('auto-time-filter').checked) {
        const dates = parseDateFromFilename(pendingFile.name);
        if (dates && !isNaN(dates.startDate) && !isNaN(dates.endDate)) {
          document.getElementById('start-time').value = dates.startDate.toISOString().slice(0, 16);
          document.getElementById('end-time').value = dates.endDate.toISOString().slice(0, 16);
          lastFilterMode = 'inputs';
          applyFilter();
        }
      }

      if (pendingFileType === 'kml') importKML({ files: [pendingFile] });
      else if (pendingFileType === 'png') importPNG({ files: [pendingFile] });

      pendingFile = null;
      pendingFileType = null;
    }

    async function fetchData() {
      const githubUrl = 'https://raw.githubusercontent.com/HandryOutlook/lightning_data/main/lightning_data.json';
      const metOfficeUrl = 'https://data.consumer-digital.api.metoffice.gov.uk/v1/lightning';

      try {
        const [githubResponse, metOfficeResponse] = await Promise.all([
          fetch(githubUrl).then(res => res.json()).catch(() => null),
          fetch(metOfficeUrl).then(res => res.json()).catch(() => null)
        ]);

        let githubStrikes = githubResponse?.lightning_strikes?.map(s => ({
          ...s,
          time: new Date(s.strike_time)
        })) || [];
        let metOfficeStrikes = metOfficeResponse?.lightning_strikes?.map(s => ({
          ...s,
          time: new Date(s.strike_time)
        })) || [];

        const allStrikes = [...githubStrikes, ...metOfficeStrikes];
        const seen = new Map();
        strikeData = allStrikes.filter(s => {
          const key = `${s.strike_time}_${s.coordinates[0]}_${s.coordinates[1]}`;
          if (!seen.has(key)) {
            seen.set(key, true);
            return true;
          }
          return false;
        });

        
        lastUpdateTime = new Date();
        document.getElementById('last-update').innerText = `Last update: ${lastUpdateTime.toLocaleString()}`;
        
        if (lastFilterMode === 'slider') {
    updateHistory(); // Calls updateNowcast()
  } else if (!(lastFilterMode === 'inputs' && customFilterStart && customFilterEnd)) {
    applyFilter(); // Calls updateNowcast()
        }
      } catch (error) {
        console.error('Error fetching lightning data:', error);
        strikeData = [];
        if (lastFilterMode === 'slider') {
          updateHistory();
        } else if (!(lastFilterMode === 'inputs' && customFilterStart && customFilterEnd)) {
          applyFilter();
        }
      }
    }

    function getColorFromAge(ageFraction) {
  
  if (ageFraction < 0.2) return '#ffd700'; // Newest
  if (ageFraction < 0.4) return '#ff69b4';
  if (ageFraction < 0.6) return '#ff00ff';
  if (ageFraction < 0.8) return '#800080';
  return '#4b0082'; // Oldest
}

    function updateLegend() {
    const legend = document.querySelector('.legend');
    let legendHTML = '<h4>Legend</h4>';

    if (document.getElementById('color-mode').checked && document.getElementById('lightning-layer-toggle').checked) {
      legendHTML += `
        <div class="legend-item"><span class="color-box" style="background: linear-gradient(to right, #EE9B00, #9B2226);"></span> Lightning Age (New to Old)</div>`;
    } else if (document.getElementById('lightning-layer-toggle').checked) {
      legendHTML += `
        <div class="legend-item"><span class="color-box" style="background: black;"></span> Lightning Strikes</div>`;
    }

    if (document.getElementById('heatmap-toggle').checked && !is3DMode) {
      legendHTML += `
        <div class="legend-item"><span class="gradient-bar" style="background: linear-gradient(to right, #001219, #0A9396, #94D2BD, #E9D8A6, #EE9B00, #CA6702, #BB3E03, #AE2012, #9B2226);"></span> Heatmap Intensity</div>`;
    }

    if (document.getElementById('heatmap-3d-toggle').checked && is3DMode) {
      legendHTML += `
        <div class="legend-item"><span class="gradient-bar" style="background: linear-gradient(to right, #001219, #0A9396, #94D2BD, #E9D8A6, #EE9B00, #CA6702, #BB3E03, #AE2012, #9B2226);"></span> 3D Heatmap Height</div>`;
    }

    if (document.getElementById('nowcast-toggle').checked) {
      legendHTML += `
        <div class="legend-item"><span class="color-box" style="background: purple;"></span> Nowcast (>90%)</div>
        <div class="legend-item"><span class="color-box" style="background: red;"></span> Nowcast (>80%)</div>
        <div class="legend-item"><span class="color-box" style="background: orange;"></span> Nowcast (>70%)</div>
        <div class="legend-item"><span class="color-box" style="background: yellow;"></span> Nowcast (>50%)</div>`;
    }

    if (document.getElementById('kml-layer-toggle').checked && kmlGeoJSON) {
      Object.keys(risk_colors).forEach(risk => {
        const isSevere = risk === 'Severe risk';
        legendHTML += `
          <div class="legend-item"><span class="color-box" style="background: ${isSevere ? 'transparent' : risk_colors[risk]}; border: 2px solid ${risk_colors[risk]};"></span> ${risk} (KML)</div>`;
      });
    }

    if (document.getElementById('drawn-polygons-toggle').checked && drawnItems.getLayers().length > 0) {
      drawnItems.eachLayer(layer => {
        const risk = layer.feature.properties.name;
        const isSevere = risk === 'Severe risk';
        legendHTML += `
          <div class="legend-item"><span class="color-box" style="background: ${isSevere ? 'transparent' : layer.options.color}; border: 2px solid ${layer.options.color};"></span> ${risk} (Drawn)</div>`;
      });
    }

    legend.innerHTML = legendHTML;
    legend.style.display = isLegendVisible ? 'block' : 'none';
  }
    function toggleLegend() {
  isLegendVisible = !isLegendVisible;
  updateLegend(); // Update visibility based on new state
}
    function applyFilter() {
      lastFilterMode = 'inputs';
      let startInput = document.getElementById('start-time').value;
      let endInput = document.getElementById('end-time').value;
      const now = new Date();

      if (!startInput) {
        const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
        startInput = new Date(now.getTime() - lifespanHours * 3600 * 1000).toISOString().slice(0, 16);
        document.getElementById('start-time').value = startInput;
      }
      if (!endInput) {
        endInput = now.toISOString().slice(0, 16);
        document.getElementById('end-time').value = endInput;
      }

      const start = new Date(startInput);
      const end = new Date(endInput);

      if (isNaN(start) || isNaN(end)) {
        console.error('Invalid date/time format.');
        alert('Invalid date/time format.');
        return;
      }

      customFilterStart = start;
      customFilterEnd = end;

      const totalMinutes = (end - start) / (60 * 1000);
      const slider = document.getElementById('history-slider');
      slider.max = Math.max(totalMinutes, parseFloat(document.getElementById('lightning-lifespan').value) * 60);
      slider.value = totalMinutes;
      slider.min = 0;

      strikeLayer.clearLayers();
      strikeCircles = [];
      const currentBounds = is3DMode ? map3D.getBounds() : map.getBounds();
      const newStrikes = new Set();

      currentFiltered = strikeData.filter(s => {
        if (showAllStrikes) {
          return s.time >= new Date(end.getTime() - parseInt(document.getElementById('max-history-hours').value) * 3600 * 1000) && s.time <= end;
        }
        return s.time >= start && s.time <= end;
      });

      currentFiltered.forEach(s => {
        const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
        newStrikes.add(strikeKey);
        const isNewStrike = !lastRenderedStrikes.has(strikeKey);
        const inBounds = is3DMode ? 
          currentBounds.contains([s.coordinates[0], s.coordinates[1]]) :
          currentBounds.contains([s.coordinates[1], s.coordinates[0]]);
        const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
        const ageFraction = (end - s.time) / (lifespanHours * 3600 * 1000);
        const color = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
        const circle = L.circleMarker([s.coordinates[1], s.coordinates[0]], {
          radius: 5,
          color: color,
          fillColor: color,
          fillOpacity: 0.8
        }).bindPopup(s.time.toISOString());
        strikeLayer.addLayer(circle);
        strikeCircles.push({ circle, strike: s });
        if (isNewStrike && inBounds && document.getElementById('lightning-layer-toggle').checked) {
          playThunderSound();
          if (!is3DMode) addLightningFlash2D(s.coordinates[1], s.coordinates[0]);
        }
      });

      lastRenderedStrikes = newStrikes;

      updateHeatmap(currentFiltered);
      updateOverlay(currentFiltered);
      updateNowcast(currentFiltered);
      document.getElementById('time-range').innerText = `Filter applied: ${start.toLocaleString()} - ${end.toLocaleString()}`;
      document.getElementById('history-label').innerText = formatTimeAgo(0);
      document.getElementById('history-time').innerText = `${start.toLocaleString()} - ${end.toLocaleString()}`;
      document.getElementById('remove-filter').style.display = 'block';
      updateZIndex();
      updateLegend();
      if (is3DMode) update3DView();
    }

    function updateStrikeColors() {
      const colorMode = document.getElementById('color-mode').checked;
      const end = new Date(document.getElementById('end-time').value);
      const lifespanHours = parseFloat(document.getElementById('lightning-lifespan').value);
      strikeCircles.forEach(({ circle, strike }) => {
        let color;
        if (colorMode) {
          const ageFraction = (end - strike.time) / (lifespanHours * 3600 * 1000);
          color = getColorFromAge(ageFraction);
        } else {
          color = 'black';
        }
        circle.setStyle({ color, fillColor: color });
      });
      if (is3DMode) update3DView();
      updateLegend();
    }

    function toggleViewMode() {
      stopAnimation();
      const button = document.getElementById('view-mode');
      showAllStrikes = !showAllStrikes;
      button.innerText = showAllStrikes ? 'Disable all strikes' : 'Enable all strikes';
      
      if (lastFilterMode === 'inputs' && customFilterStart && customFilterEnd) {
        applyFilter();
      } else {
        updateHistory();
      }
    }

    function updateHeatmap(filtered) {
      if (is3DMode) {
        update3DView();
      } else {
        const data = filtered.map(s => [s.coordinates[1], s.coordinates[0], 1]);
        const blur = parseInt(document.getElementById('blur-slider').value);
        if (heatmapLayer) map.removeLayer(heatmapLayer);

        heatmapLayer = L.heatLayer(data, {
          radius: blur,
          blur: 15,
          maxZoom: 10,
          minZoom: 10,
          gradient: { 0.0: '#001219', 0.1: '#001219', 0.2: '#0A9396', 0.3: '#94D2BD', 0.4: '#E9D8A6', 0.5: '#c89578', 0.6: '#EE9B00', 0.7: '#CA6702', 0.8: '#BB3E03', 0.9: '#AE2012', 1.0: '#9B2226' }
        });

        if (document.getElementById('heatmap-toggle').checked) {
          heatmapLayer.addTo(map);
          heatmapLayer._canvas.style.zIndex = 70;
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }

    function toggleHeatmap() {
      if (is3DMode) {
        update3DView();
      } else {
        if (document.getElementById('heatmap-toggle').checked) {
          if (heatmapLayer) {
            heatmapLayer.addTo(map);
            heatmapLayer._canvas.style.zIndex = 70;
          }
        } else {
          if (heatmapLayer) map.removeLayer(heatmapLayer);
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }

    function toggleLightningLayer() {
      if (is3DMode) {
        update3DView();
      } else {
        if (document.getElementById('lightning-layer-toggle').checked) {
          if (!map.hasLayer(strikeLayer)) {
            map.addLayer(strikeLayer);
          }
        } else {
          map.removeLayer(strikeLayer);
        }
        updateZIndex();
        map.invalidateSize();
      }
      updateLegend();
    }
       
  function toggleKMLLayer() {
  const toggle = document.getElementById('kml-layer-toggle').checked;
  if (is3DMode) {
    // Remove existing layers and source if they exist
    if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
    if (map3D.getLayer('kml-layer-outline')) map3D.removeLayer('kml-layer-outline');
    if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');
    
    if (toggle && kmlGeoJSON) {
      // Add new source and layers only if toggle is enabled and kmlGeoJSON exists
      map3D.addSource('kml-source', { type: 'geojson', data: kmlGeoJSON });
      map3D.addLayer({
        id: 'kml-layer',
        type: 'fill',
        source: 'kml-source',
        paint: {
          'fill-color': [
            'match',
            ['get', 'name'],
            'Low risk', risk_colors['Low risk'],
            'Slight risk', risk_colors['Slight risk'],
            'Enhanced risk', risk_colors['Enhanced risk'],
            'Moderate risk', risk_colors['Moderate risk'],
            'High risk', risk_colors['High risk'],
            'transparent' // Transparent for Severe risk or unknown
          ],
          'fill-opacity': [
            'match',
            ['get', 'name'],
            'Low risk', 0.3,
            'Slight risk', 0.3,
            'Enhanced risk', 0.3,
            'Moderate risk', 0.3,
            'High risk', 0.3,
            0 // No fill for Severe risk or unknown
          ]
        }
      });
      map3D.addLayer({
        id: 'kml-layer-outline',
        type: 'line',
        source: 'kml-source',
        paint: {
          'line-color': [
            'match',
            ['get', 'name'],
            'Low risk', risk_colors['Low risk'],
            'Slight risk', risk_colors['Slight risk'],
            'Enhanced risk', risk_colors['Enhanced risk'],
            'Moderate risk', risk_colors['Moderate risk'],
            'High risk', risk_colors['High risk'],
            risk_colors['Severe risk'] // Black outline for Severe risk or unknown
          ],
          'line-width': 2,
          'line-opacity': 1
        }
      });
      map3D.resize();
    }
  } else {
    if (toggle && kmlLayer && !map.hasLayer(kmlLayer)) {
      map.addLayer(kmlLayer);
      kmlLayer.setZIndex(60);
    } else if (kmlLayer) {
      map.removeLayer(kmlLayer);
    }
    updateZIndex();
    map.invalidateSize();
  }
  updateLegend();
}

function togglePNGLayer() {
  const toggle = document.getElementById('png-layer-toggle').checked;
  if (is3DMode) {
    if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
    if (map3D.getSource('png-source')) map3D.removeSource('png-source');
    if (toggle && pngImage && pngBounds) {
      map3D.addSource('png-source', {
        type: 'image',
        url: pngImage,
        coordinates: [
          [pngBounds[0][1], pngBounds[1][0]],
          [pngBounds[1][1], pngBounds[1][0]],
          [pngBounds[1][1], pngBounds[0][0]],
          [pngBounds[0][1], pngBounds[0][0]]
        ]
      });
      map3D.addLayer({
        id: 'png-layer',
        type: 'raster',
        source: 'png-source',
        paint: {
          'raster-opacity': parseFloat(document.getElementById('png-opacity-slider').value)
        }
      });
    }
  } else {
    if (toggle && pngLayer && !map.hasLayer(pngLayer)) {
      map.addLayer(pngLayer);
      pngLayer.setZIndex(40);
    } else if (pngLayer) {
      map.removeLayer(pngLayer);
    }
    updateZIndex();
    map.invalidateSize();
  }
  updateLegend();
}

    
    function updateZIndex() {
  const expertMode = document.getElementById('expert-mode').checked;
  const lightningZ = expertMode ? parseInt(document.getElementById('lightning-zindex').value) || 1000 : 1000;
  const heatmapZ = expertMode ? parseInt(document.getElementById('heatmap-zindex').value) || 70 : 70;
  const kmlZ = expertMode ? parseInt(document.getElementById('kml-zindex').value) || 60 : 60;
  const pngZ = expertMode ? parseInt(document.getElementById('png-zindex').value) || 40 : 40;
  const numbersZ = expertMode ? parseInt(document.getElementById('numbers-zindex').value) || 1200 : 1200;
  const nowcastZ = Math.max(kmlZ, pngZ) + 10; // Ensure nowcast is above KML and PNG, but below lightning

  // Remove all layers to re-add them in the correct order
  if (nowcastLayer && map.hasLayer(nowcastLayer)) map.removeLayer(nowcastLayer);
  if (strikeLayer && map.hasLayer(strikeLayer)) map.removeLayer(strikeLayer);
  if (kmlLayer && map.hasLayer(kmlLayer)) map.removeLayer(kmlLayer);
  if (pngLayer && map.hasLayer(pngLayer)) map.removeLayer(pngLayer);
  if (heatmapLayer && map.hasLayer(heatmapLayer)) map.removeLayer(heatmapLayer);
  if (numberOverlay && map.hasLayer(numberOverlay)) map.removeLayer(numberOverlay);

  // Add layers back in desired order: heatmap, png, kml, nowcast, lightning, numbers
  if (heatmapLayer && document.getElementById('heatmap-toggle').checked) {
    heatmapLayer._canvas.style.zIndex = heatmapZ;
    map.addLayer(heatmapLayer);
  }
  if (pngLayer && document.getElementById('png-layer-toggle').checked) {
    pngLayer.setZIndex(pngZ);
    map.addLayer(pngLayer);
  }
  if (kmlLayer && document.getElementById('kml-layer-toggle').checked) {
    kmlLayer.setZIndex(kmlZ);
    map.addLayer(kmlLayer);
  }
  if (nowcastLayer && document.getElementById('nowcast-toggle').checked) {
    nowcastLayer.eachLayer(layer => {
      if (layer.setZIndex) layer.setZIndex(nowcastZ);
    });
    nowcastLayer.setZIndex(nowcastZ);
    map.addLayer(nowcastLayer);
  }
  if (strikeLayer && document.getElementById('lightning-layer-toggle').checked) {
    strikeLayer.setZIndex(lightningZ);
    map.addLayer(strikeLayer);
  }
  if (numberOverlay && document.getElementById('number-overlay-toggle').checked) {
    numberOverlay.setZIndex(numbersZ);
    map.addLayer(numberOverlay);
  }

  // In 3D mode, ensure correct layer order by re-adding layers
  if (is3DMode) {
    // Remove existing 3D layers
    if (map3D.getLayer('png-layer')) map3D.removeLayer('png-layer');
    if (map3D.getSource('png-source')) map3D.removeSource('png-source');
    if (map3D.getLayer('kml-layer')) map3D.removeLayer('kml-layer');
    if (map3D.getLayer('kml-layer-outline')) map3D.removeLayer('kml-layer-outline');
    if (map3D.getSource('kml-source')) map3D.removeSource('kml-source');
    nowcastLayer3D.forEach(layer => {
      if (map3D.getLayer(layer.id)) map3D.removeLayer(layer.id);
      if (map3D.getSource(layer.source)) map3D.removeSource(layer.source);
    });
    strikeLayer3D.forEach(marker => marker.remove());
    strikeLayer3D = [];

    // Re-add PNG layer
    if (document.getElementById('png-layer-toggle').checked && pngImage && pngBounds) {
      map3D.addSource('png-source', {
        type: 'image',
        url: pngImage,
        coordinates: [
          [pngBounds[0][1], pngBounds[1][0]],
          [pngBounds[1][1], pngBounds[1][0]],
          [pngBounds[1][1], pngBounds[0][0]],
          [pngBounds[0][1], pngBounds[0][0]]
        ]
      });
      map3D.addLayer({
        id: 'png-layer',
        type: 'raster',
        source: 'png-source',
        paint: {
          'raster-opacity': parseFloat(document.getElementById('png-opacity-slider').value)
        }
      });
    }

    // Re-add KML layer
    if (document.getElementById('kml-layer-toggle').checked && kmlGeoJSON) {
      map3D.addSource('kml-source', { type: 'geojson', data: kmlGeoJSON });
      map3D.addLayer({
        id: 'kml-layer',
        type: 'fill',
        source: 'kml-source',
        paint: {
          'fill-color': [
            'match',
            ['get', 'name'],
            'Low risk', risk_colors['Low risk'],
            'Slight risk', risk_colors['Slight risk'],
            'Enhanced risk', risk_colors['Enhanced risk'],
            'Moderate risk', risk_colors['Moderate risk'],
            'High risk', risk_colors['High risk'],
            'transparent'
          ],
          'fill-opacity': [
            'match',
            ['get', 'name'],
            'Low risk', 0.3,
            'Slight risk', 0.3,
            'Enhanced risk', 0.3,
            'Moderate risk', 0.3,
            'High risk', 0.3,
            0
          ]
        }
      });
      map3D.addLayer({
        id: 'kml-layer-outline',
        type: 'line',
        source: 'kml-source',
        paint: {
          'line-color': [
            'match',
            ['get', 'name'],
            'Low risk', risk_colors['Low risk'],
            'Slight risk', risk_colors['Slight risk'],
            'Enhanced risk', risk_colors['Enhanced risk'],
            'Moderate risk', risk_colors['Moderate risk'],
            'High risk', risk_colors['High risk'],
            risk_colors['Severe risk']
          ],
          'line-width': 2,
          'line-opacity': 1
        }
      });
    }

    // Re-add nowcast layers
    if (document.getElementById('nowcast-toggle').checked) {
      currentNowcasts.forEach((cluster, index) => {
        if (cluster.confidenceScore >= minNowcastConfidence) {
          const confidenceColor = cluster.confidenceScore > 0.9 ? 'purple' :
                                  cluster.confidenceScore > 0.8 ? 'red' :
                                  cluster.confidenceScore > 0.7 ? 'orange' : 'yellow';
          const radiusKm = cluster.confidenceScore * 5 + 5;
          const coneRadiusKm = cluster.confidenceScore * 30 + 30;
          const radiusDeg = radiusKm / 111;

          map3D.addSource(`nowcast-circle-${index}`, {
            type: 'geojson',
            data: {
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: [cluster.baseLon, cluster.baseLat]
              },
              properties: { radius: radiusDeg }
            }
          });
          map3D.addLayer({
            id: `nowcast-circle-${index}`,
            type: 'circle',
            source: `nowcast-circle-${index}`,
            paint: {
              'circle-radius': [
                'interpolate',
                ['linear'],
                ['zoom'],
                5, (radiusKm * 1000) / 1000,
                10, (radiusKm * 1000) / 250
              ],
              'circle-color': confidenceColor,
              'circle-opacity': 0.5,
              'circle-stroke-color': confidenceColor,
              'circle-stroke-width': 2,
              'circle-stroke-opacity': 0.8
            }
          });
          nowcastLayer3D.push({ id: `nowcast-circle-${index}`, source: `nowcast-circle-${index}` });

          const at = turf.sector(
            [cluster.baseLon, cluster.baseLat],
            coneRadiusKm,
            cluster.directionDeg - 15,
            cluster.directionDeg + 15,
            { units: 'kilometers' }
          );
          map3D.addSource(`nowcast-cone-${index}`, {
            type: 'geojson',
            data: cone
          });
          map3D.addLayer({
            id: `nowcast-cone-${index}`,
            type: 'fill',
            source: `nowcast-cone-${index}`,
            paint: {
              'fill-color': confidenceColor,
              'fill-opacity': 0.5
            }
          });
          nowcastLayer3D.push({ id: `nowcast-cone-${index}`, source: `nowcast-cone-${index}` });
        }
      });
    }

    // Re-add lightning layer
    if (document.getElementById('lightning-layer-toggle').checked) {
      currentFiltered.forEach(s => {
        const ageFraction = (animationEnd - s.time) / (parseFloat(document.getElementById('lightning-lifespan').value) * 3600 * 1000);
        const el = document.createElement('div');
        el.className = 'marker';
        el.style.backgroundColor = document.getElementById('color-mode').checked ? getColorFromAge(ageFraction) : 'black';
        el.style.width = '10px';
        el.style.height = '10px';
        el.style.borderRadius = '50%';
        const marker = new mapboxgl.Marker(el)
          .setLngLat([s.coordinates[0], s.coordinates[1]])
          .setPopup(new mapboxgl.Popup().setText(s.time.toISOString()))
          .addTo(map3D);
        strikeLayer3D.push(marker);
      });
    }
  }
}

    function updateOverlay(filtered) {
      if (numberOverlay) {
        map.removeLayer(numberOverlay);
        numberOverlay = null;
      }
      numberOverlay3D.forEach(marker => marker.remove());
      numberOverlay3D = [];

      if (!document.getElementById('number-overlay-toggle').checked) return;

      const density = parseInt(document.getElementById('density-slider').value);
      const UK_BBOX = [-15, 49, 8, 61];
      const [minLng, minLat, maxLng, maxLat] = UK_BBOX;

      const latStep = (maxLat - minLat) / density;
      const lngStep = (maxLng - minLng) / density;
      const grid = new Map();

      for (let i = 0; i < density; i++) {
        for (let j = 0; j < density; j++) grid.set(`${i}_${j}`, 0);
      }

      filtered.forEach(s => {
        const lat = s.coordinates[1];
        const lng = s.coordinates[0];
        if (lat >= minLat && lat <= maxLat && lng >= minLng && lng <= maxLng) {
          const i = Math.floor((lat - minLat) / latStep);
          const j = Math.floor((lng - minLng) / lngStep);
          const key = `${i}_${j}`;
          if (grid.has(key)) grid.set(key, grid.get(key) + 1);
        }
      });

      if (is3DMode) {
        grid.forEach((count, key) => {
          if (count === 0) return;
          const [i, j] = key.split('_').map(Number);
          const cellLat = minLat + (i + 0.5) * latStep;
          const cellLng = minLng + (j + 0.5) * lngStep;
          const el = document.createElement('div');
          el.innerHTML = `<b style="font-size:12px;color:white;-webkit-text-stroke:1px black;">${count}</b>`;
          const marker = new mapboxgl.Marker(el)
            .setLngLat([cellLng, cellLat])
            .addTo(map3D);
          numberOverlay3D.push(marker);
        });
      } else {
        numberOverlay = L.layerGroup();
        grid.forEach((count, key) => {
          if (count === 0) return;
          const[i, j] = key.split('_').map(Number);
          const cellLat = minLat + (i + 0.5) * latStep;
          const cellLng = minLng + (j + 0.5) * lngStep;
          const text = L.divIcon({
            html: `<b style="font-size:12px;color:white;-webkit-text-stroke:1px black;">${count}</b>`,
            className: ''
          });
          const marker = L.marker([cellLat, cellLng], { icon: text });
          numberOverlay.addLayer(marker);
        });
        numberOverlay.addTo(map);
        numberOverlay.setZIndex(parseInt(document.getElementById('numbers-zindex').value) || 1200);
      }
      updateZIndex();
    }

    function switchBaseMap(style) {
      Object.values(baseLayers).forEach(layer => {
        if (map.hasLayer(layer)) map.removeLayer(layer);
      });
      baseLayers[style].addTo(map);
      updateZIndex();
      map.invalidateSize();
    }

    function playAnimation() {
  if (isPlaying) return;
  isPlaying = true;
  const slider = document.getElementById('history-slider');
  let currentValue = parseFloat(slider.value);
  const maxValue = parseFloat(slider.max);
  const speed = parseFloat(document.getElementById('speed-slider').value); // Minutes per second
  let lastFrameTime = performance.now();

  function animate(currentTime) {
    if (!isPlaying) return;

    const deltaTime = (currentTime - lastFrameTime) / 1000; // Time since last frame in seconds
    lastFrameTime = currentTime;

    // Increment slider value: speed (min/sec) * deltaTime (sec) = minutes to advance
    currentValue += speed * deltaTime;

    if (currentValue >= maxValue) {
      currentValue = maxValue;
      slider.value = currentValue;
      updateHistory();
      stopAnimation();
      return;
    }

    slider.value = currentValue;
    updateHistory();

    animationInterval = requestAnimationFrame(animate);
  }

  animationInterval = requestAnimationFrame(animate);
}

function stopAnimation() {
  if (animationInterval) {
    cancelAnimationFrame(animationInterval);
    animationInterval = null;
  }
  isPlaying = false;
}

    function toggleFullScreen() {
      const container = document.body;
      isFullScreen = !isFullScreen;
      if (isFullScreen) {
        container.classList.add('fullscreen');
        if (document.requestFullscreen) {
          container.requestFullscreen();
        } else if (document.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        } else if (document.msRequestFullscreen) {
          container.msRequestFullscreen();
        }
      } else {
        container.classList.remove('fullscreen');
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
      if (is3DMode) {
        map3D.resize();
      } else {
        map.invalidateSize();
      }
    }

    function updateSpeedSlider() {
  const slider = document.getElementById('speed-slider');
  const textbox = document.getElementById('playback-minutes');
  let value = parseFloat(textbox.value) || 1;
  value = Math.max(1, Math.min(100, value)); // Clamp between 0.01 and 10
  slider.value = value;
  textbox.value = value.toFixed(2);
  if (isPlaying) {
    stopAnimation();
    playAnimation();
  }
}

function updateSpeedTextbox() {
  const slider = document.getElementById('speed-slider');
  const textbox = document.getElementById('playback-minutes');
  const value = parseFloat(slider.value);
  textbox.value = value.toFixed(2); // Ensure two decimal places
  if (isPlaying) {
    stopAnimation();
    playAnimation();
  }
}

    function updatePNGOpacity() {
      const opacity = parseFloat(document.getElementById('png-opacity-slider').value);
      if (is3DMode && map3D.getLayer('png-layer')) {
        map3D.setPaintProperty('png-layer', 'raster-opacity', opacity);
      } else if (pngLayer && map.hasLayer(pngLayer)) {
        pngLayer.setOpacity(opacity);
      }
    }

    function importKML(input) {
  if (!input.files || !input.files[0]) return alert('No KML file selected.');
  const file = input.files[0];
  if (document.getElementById('auto-time-filter').checked && !pendingFile) {
    showTimeFilterModal(file, 'kml');
    return;
  }
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const parser = new DOMParser();
      const kml = parser.parseFromString(e.target.result, 'text/xml');
      kmlGeoJSON = toGeoJSON.kml(kml);
      if (kmlLayer) map.removeLayer(kmlLayer);
      kmlLayer = L.geoJSON(kmlGeoJSON, {
        style: function(feature) {
          const name = feature.properties.name || '';
          const isSevere = name === 'Severe risk';
          return risk_colors[name] ? {
            color: risk_colors[name],
            fillColor: isSevere ? 'transparent' : risk_colors[name],
            fillOpacity: isSevere ? 0 : 0.3,
            weight: 2
          } : { color: 'black', fillOpacity: 0 };
        },
        onEachFeature: (f, l) => {
          if (f.properties.name) l.bindPopup(f.properties.name);
        }
      });
      if (document.getElementById('expert-mode').checked) {
        if (document.getElementById('kml-layer-toggle').checked && !is3DMode) {
          kmlLayer.addTo(map);
          kmlLayer.setZIndex(1500);
        }
        if (is3DMode) toggleKMLLayer();
      }
      updateZIndex();
      updateLegend();
    } catch (error) {
      console.error('Error parsing KML:', error);
      alert('Failed to parse KML file.');
    }
  };
  reader.readAsText(file);
}

   function importPNG(input) {
  if (!input.files || !input.files[0]) return alert('No PNG file selected.');
  const file = input.files[0];
  if (document.getElementById('auto-time-filter').checked && !pendingFile) {
    showTimeFilterModal(file, 'png');
    return;
  }
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      pngImage = e.target.result;
      let bounds = region_bounds['UK'];
      for (const [region, regionBounds] of Object.entries(region_bounds)) {
        if (file.name.toLowerCase().includes(region.toLowerCase())) {
          bounds = regionBounds;
          break;
        }
      }
      pngBounds = bounds;
      if (pngLayer) map.removeLayer(pngLayer);
      pngLayer = L.imageOverlay(pngImage, bounds, {
        opacity: parseFloat(document.getElementById('png-opacity-slider').value)
      });
      // Only add layer if Expert Mode is enabled
      if (document.getElementById('expert-mode').checked) {
        if (document.getElementById('png-layer-toggle').checked && !is3DMode) {
          pngLayer.addTo(map);
          pngLayer.setZIndex(1400);
        }
        if (is3DMode) togglePNGLayer();
      }
      updateZIndex();
      updateLegend();
    } catch (error) {
      console.error('Error loading PNG:', error);
      alert('Failed to load PNG file.');
    }
  };
  reader.readAsDataURL(file);
}
    function toggleNowcast() {
  minNowcastConfidence = parseFloat(document.getElementById('min-nowcast-confidence').value);

  // Remove existing nowcast layers in 2D mode
  nowcastLayer.clearLayers();

  if (document.getElementById('nowcast-toggle').checked && !is3DMode) {
    currentNowcasts = calculateLightningNowcast(currentFiltered);
    currentNowcasts.forEach((cluster, index) => {
      if (cluster.confidenceScore >= minNowcastConfidence) {
        const confidenceColor = cluster.confidenceScore > 0.9 ? 'purple' :
                                cluster.confidenceScore > 0.8 ? 'red' :
                                cluster.confidenceScore > 0.7 ? 'orange' : 'yellow';
        const radiusKm = cluster.confidenceScore * 5 + 5;
        const coneRadiusKm = cluster.confidenceScore * 30 + 30;

        // Add circle for cluster center
        L.circle([cluster.baseLat, cluster.baseLon], {
          color: confidenceColor,
          fillColor: confidenceColor,
          fillOpacity: 0.5,
          radius: radiusKm * 1000 // Convert to meters
        }).addTo(nowcastLayer);

        // Add cone using turf.js
        const cone = turf.sector(
          [cluster.baseLon, cluster.baseLat],
          coneRadiusKm,
          cluster.directionDeg - 15,
          cluster.directionDeg + 15,
          { units: 'kilometers' }
        );
        L.geoJSON(cone, {
          style: {
            fillColor: confidenceColor,
            fillOpacity: 0.5,
            color: confidenceColor,
            weight: 1
          }
        }).addTo(nowcastLayer);
      }
    });
  }

  // Ensure the layer is added to the map if enabled
  if (document.getElementById('nowcast-toggle').checked && map.hasLayer(nowcastLayer)) {
    map.addLayer(nowcastLayer);
  } else if (!document.getElementById('nowcast-toggle').checked && map.hasLayer(nowcastLayer)) {
    map.removeLayer(nowcastLayer);
  }

  updateLegend();
}

    function updateNowcast(filtered) {
  nowcastLayer.clearLayers();
  nowcastLayer3D.forEach(layer => {
    if (map3D.getLayer(layer.id)) map3D.removeLayer(layer.id);
    if (map3D.getSource(layer.source)) map3D.removeSource(layer.source);
  });
  nowcastLayer3D = [];

  if (!document.getElementById('nowcast-toggle').checked) return;

  minNowcastConfidence = parseFloat(document.getElementById('min-nowcast-confidence').value);
  currentNowcasts = calculateLightningNowcast(filtered);

  

  currentNowcasts.forEach((cluster, index) => {
    if (cluster.confidenceScore >= minNowcastConfidence) { // Apply confidence filter
      const confidenceColor = cluster.confidenceScore > 0.9 ? 'purple' :
                              cluster.confidenceScore > 0.8 ? 'red' :
                              cluster.confidenceScore > 0.7 ? 'orange' : 'yellow';
      const radiusKm = cluster.confidenceScore * 5 + 5;
      const coneRadiusKm = cluster.confidenceScore * 30 + 30;
      const radiusDeg = radiusKm / 111;

          if (is3DMode) {
        // Render cluster circle
        map3D.addSource(`nowcast-circle-${index}`, {
          type: 'geojson',
          data: {
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [cluster.baseLon, cluster.baseLat]
            },
            properties: { radius: radiusDeg }
          }
        });
        map3D.addLayer({
          id: `nowcast-circle-${index}`,
          type: 'circle',
          source: `nowcast-circle-${index}`,
          paint: {
            'circle-radius': [
              'interpolate',
              ['linear'],
              ['zoom'],
              5, (radiusKm * 1000) / 1000,
              10, (radiusKm * 1000) / 250
            ],
            'circle-color': confidenceColor,
            'circle-opacity': 0.5,
            'circle-stroke-color': confidenceColor,
            'circle-stroke-width': 2,
            'circle-stroke-opacity': 0.8
          }
        });
        nowcastLayer3D.push({ id: `nowcast-circle-${index}`, source: `nowcast-circle-${index}` });

        // Render cone
        const cone = turf.sector(
          [cluster.baseLon, cluster.baseLat],
          coneRadiusKm,
          cluster.directionDeg - 15,
          cluster.directionDeg + 15,
          { units: 'kilometers' }
        );
        map3D.addSource(`nowcast-cone-${index}`, {
          type: 'geojson',
          data: cone
        });
        map3D.addLayer({
          id: `nowcast-cone-${index}`,
          type: 'fill',
          source: `nowcast-cone-${index}`,
          paint: {
            'fill-color': confidenceColor,
            'fill-opacity': 0.5
          }
        });
        nowcastLayer3D.push({ id: `nowcast-cone-${index}`, source: `nowcast-cone-${index}` });
      } else {
        // Render cluster circle
        const circle = L.circle([cluster.baseLat, cluster.baseLon], {
          radius: radiusDeg * 111 * 1000,
          color: confidenceColor,
          fillColor: confidenceColor,
          fillOpacity: 0.5,
          weight: 2,
          className: 'nowcast-cluster'
        }).bindPopup(`
          <b>Nowcast Cluster</b><br>
          Confidence: ${(cluster.confidenceScore * 100).toFixed(1)}%<br>
          Speed: ${cluster.speedKmH.toFixed(1)} km/h<br>
          Direction: ${cluster.directionDeg.toFixed(1)}°
        `);
        nowcastLayer.addLayer(circle);

        // Render cone
        const cone = turf.sector(
          [cluster.baseLon, cluster.baseLat],
          coneRadiusKm,
          cluster.directionDeg - 15,
          cluster.directionDeg + 15,
          { units: 'kilometers' }
        );
        const coneLayer = L.geoJSON(cone, {
          style: {
            color: confidenceColor,
            fillColor: confidenceColor,
            fillOpacity: 0.5,
            weight: 1,
            className: 'nowcast-cone'
          }
        });
        nowcastLayer.addLayer(coneLayer);
      }
    }
  });

  if (!is3DMode && document.getElementById('nowcast-toggle').checked) {
    nowcastLayer.addTo(map);
  }
  updateZIndex();
  updateLegend();
}

    function calculateLightningNowcast(lightningData) {
  if (!lightningData || lightningData.length === 0) return [];

  const maxDistance = 50; // Max distance for clustering (km)
  const minClusterSize = 3; // Minimum strikes per cluster
  const maxTimeRange = 1 * 3600 * 1000; // 3 hours
  const binSize = 5 * 60 * 1000; // 5-minute bins
  const decayConstant = 2; // Decay for weighting recent strikes
  const ransacIterations = 100; // RANSAC iterations for regression
  const ransacThreshold = 0.1; // RANSAC threshold for inliers
  const inactivityThreshold = 15 * 60 * 1000; // 15 minutes in milliseconds

  // Use animationEnd if defined (during animation), otherwise current time
  const referenceTime = animationEnd ? new Date(animationEnd) : new Date();

  
  // Form clusters based on spatial and temporal proximity
  const clusters = [];
  const used = new Set();
  for (let i = 0; i < lightningData.length; i++) {
    if (used.has(i)) continue;
    const cluster = [lightningData[i]];
    used.add(i);
    for (let j = i + 1; j < lightningData.length; j++) {
      if (used.has(j)) continue;
      const dist = Math.sqrt(
        Math.pow((lightningData[j].coordinates[0] - lightningData[i].coordinates[0]) * 111 * Math.cos(lightningData[i].coordinates[1] * Math.PI / 180), 2) +
        Math.pow((lightningData[j].coordinates[1] - lightningData[i].coordinates[1]) * 111, 2)
      );
      if (dist <= maxDistance && Math.abs(lightningData[j].time - lightningData[i].time) <= maxTimeRange) {
        cluster.push(lightningData[j]);
        used.add(j);
      }
    }
    if (cluster.length >= minClusterSize) clusters.push(cluster);
  }

  

  const clusterInfos = [];
  clusters.forEach((cluster, c) => {
    const minTime = Math.min(...cluster.map(s => s.time.getTime()));
    const maxTime = Math.max(...cluster.map(s => s.time.getTime()));
    const lastStrikeTime = new Date(maxTime); // Most recent strike in the cluster

   
    // Create time bins for centroid calculation
    const bins = [];
    for (let t = minTime; t < maxTime; t += binSize) {
      const binStart = t;
      const binEnd = t + binSize;
      const binStrikes = cluster.filter(s => s.time.getTime() >= binStart && s.time.getTime() < binEnd);
      if (binStrikes.length > 0) {
        let sumLat = 0, sumLon = 0, sumWeight = 0;
        binStrikes.forEach(s => {
          const weight = Math.exp(-decayConstant * (maxTime - s.time.getTime()) / (maxTime - minTime));
          sumLat += s.coordinates[1] * weight;
          sumLon += s.coordinates[0] * weight;
          sumWeight += weight;
        });
        const centroidLat = sumLat / sumWeight;
        const centroidLon = sumLon / sumWeight;
        const binTime = (binStart + binEnd) / 2;
        bins.push({ time: binTime, lat: centroidLat, lon: centroidLon, count: binStrikes.length });
      }
    }

    if (bins.length === 0) return;
    

    let speedLatDegPerSec = 0, speedLonDegPerSec = 0, regressionScore = 0, speedKmH = 0, directionDeg = 0;
    if (bins.length >= 2) {
      const ransacModel = ransacRegression(bins, ransacIterations, ransacThreshold);
      speedLatDegPerSec = ransacModel.slopeLat;
      speedLonDegPerSec = ransacModel.slopeLon;
      regressionScore = ransacModel.r2;

      const latFactor = Math.cos(bins[0].lat * Math.PI / 180);
      const speedLatKmH = speedLatDegPerSec * 111 * 3600;
      const speedLonKmH = speedLonDegPerSec * 111 * latFactor * 3600;
      speedKmH = Math.sqrt(speedLatKmH * speedLatKmH + speedLonKmH * speedLonKmH);
      directionDeg = (Math.atan2(speedLonKmH, speedLatKmH) * 180 / Math.PI + 360) % 360;
    } else {
      // Single bin: assume stationary cluster with default direction
      regressionScore = 0.3;
      directionDeg = 0; // Default to north
    }

    

    const clusterSizeScore = Math.min(cluster.length / 50, 1);
    const velocityScore = Math.min(speedKmH / 100, 1);
    const timeSpanScore = Math.min((maxTime - minTime) / maxTimeRange, 1);
    const confidenceScore = (clusterSizeScore * 0.4 + velocityScore * 0.2 + regressionScore * 0.2 + timeSpanScore * 0.2) * (bins.length >= 2 ? 1 : 0.6);

    const baseLat = bins[bins.length - 1].lat;
    const baseLon = bins[bins.length - 1].lon;

    // Moderate speed and direction with nearby clusters
    let moderatedSpeedKmH = speedKmH;
    let moderatedDirectionDeg = directionDeg;
    let neighborSpeeds = [speedKmH * confidenceScore * 2]; // Increase weight of own cluster
    let neighborWeights = confidenceScore * 2;
    let neighborSinSum = Math.sin(directionDeg * Math.PI / 180) * confidenceScore * 2;
    let neighborCosSum = Math.cos(directionDeg * Math.PI / 180) * confidenceScore * 2;
    let neighborCount = 1;

    const latFactorCluster = Math.cos(baseLat * Math.PI / 180);
    for (let nc = 0; nc < clusterInfos.length; nc++) {
      const otherCluster = clusterInfos[nc];
      const distToNeighbor = Math.sqrt(
        Math.pow((otherCluster.baseLon - baseLon) * 111 * latFactorCluster, 2) +
        Math.pow((otherCluster.baseLat - baseLat) * 111, 2)
      );
      if (distToNeighbor <= 200) { // Reduced from 400 km
        const weight = otherCluster.confidenceScore / (distToNeighbor + 1);
        neighborSpeeds.push(otherCluster.speedKmH * weight);
        neighborSinSum += Math.sin(otherCluster.directionDeg * Math.PI / 180) * weight;
        neighborCosSum += Math.cos(otherCluster.directionDeg * Math.PI / 180) * weight;
        neighborWeights += weight;
        neighborCount++;
      }
    }

    if (neighborCount > 1) {
      moderatedSpeedKmH = neighborSpeeds.reduce((a, b) => a + b, 0) / neighborWeights;
      const moderatedDirectionRad = Math.atan2(neighborSinSum / neighborWeights, neighborCosSum / neighborWeights);
      moderatedDirectionDeg = (moderatedDirectionRad * 180 / Math.PI + 360) % 360;
    }

    clusterInfos.push({
      baseLat,
      baseLon,
      speedKmH: moderatedSpeedKmH,
      directionDeg: moderatedDirectionDeg,
      confidenceScore,
      clusterSize: cluster.length,
      timeSpan: maxTime - minTime,
      lastStrikeTime // Store for reference
    });
  });

  
  return clusterInfos;
}

    function ransacRegression(bins, iterations, threshold) {
      let bestModel = { slopeLat: 0, slopeLon: 0, interceptLat: 0, interceptLon: 0, r2: 0 };
      let maxInliers = 0;

      for (let i = 0; i < iterations; i++) {
        const sample = randomSample(bins, 2);
        const model = fitLinearModel(sample);
        const inliers = bins.filter(b => {
          const t = (b.time - sample[0].time) / 1000;
          const predLat = model.interceptLat + model.slopeLat * t;
          const predLon = model.interceptLon + model.slopeLon * t;
          return Math.abs(b.lat - predLat) < threshold && Math.abs(b.lon - predLon) < threshold;
        });

        if (inliers.length > maxInliers) {
          maxInliers = inliers.length;
          bestModel = fitLinearModel(inliers.length >= 2 ? inliers : sample);
        }
      }

      return bestModel;
    }

    function fitLinearModel(bins) {
      let sumT = 0, sumLat = 0, sumLon = 0, sumTLat = 0, sumTLon = 0, sumT2 = 0, sumWeight = 0;
      const n = bins.length;
      const baseTime = bins[0].time;
      const decayConstant = 2;
      const maxTime = Math.max(...bins.map(b => b.time));
      const minTime = Math.min(...bins.map(b => b.time));

      bins.forEach(b => {
        const t = (b.time - baseTime) / 1000;
        const weight = Math.exp(-decayConstant * (maxTime - b.time) / (maxTime - minTime));
        sumT += t * weight;
        sumLat += b.lat * weight;
        sumLon += b.lon * weight;
        sumTLat += t * b.lat * weight;
        sumTLon += t * b.lon * weight;
        sumT2 += t * t * weight;
        sumWeight += weight;
      });

      const denominator = sumT2 * sumWeight - sumT * sumT;
      const slopeLat = denominator !== 0 ? (sumTLat * sumWeight - sumT * sumLat) / denominator : 0;
      const slopeLon = denominator !== 0 ? (sumTLon * sumWeight - sumT * sumLon) / denominator : 0;
      const interceptLat = (sumLat - slopeLat * sumT) / sumWeight;
      const interceptLon = (sumLon - slopeLon * sumT) / sumWeight;

      let ssTotLat = 0, ssResLat = 0;
      const meanLat = sumLat / sumWeight;
      bins.forEach(b => {
        const t = (b.time - baseTime) / 1000;
        const weight = Math.exp(-decayConstant * (maxTime - b.time) / (maxTime - minTime));
        ssTotLat += weight * Math.pow(b.lat - meanLat, 2);
        ssResLat += weight * Math.pow(b.lat - (interceptLat + slopeLat * t), 2);
      });
      const r2 = ssTotLat > 0 ? 1 - ssResLat / ssTotLat : 0;

      return { slopeLat, slopeLon, interceptLat, interceptLon, r2 };
    }

    function randomSample(array, n) {
      const result = [];
      const indices = Array.from({ length: array.length }, (_, i) => i);
      for (let i = 0; i < n && indices.length > 0; i++) {
        const idx = Math.floor(Math.random() * indices.length);
        result.push(array[indices.splice(idx, 1)[0]]);
      }
      return result;
    }

    function initializeDragAndDrop() {
      const mapDiv = document.getElementById('map');
      const map3DDiv = document.getElementById('map-3d');

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
        mapDiv.addEventListener(evt, handleDragDrop, false);
        map3DDiv.addEventListener(evt, handleDragDrop, false);
      });
    }

    function handleDragDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      const mapDiv = document.getElementById('map');
      const map3DDiv = document.getElementById('map-3d');

      if (e.type === 'dragenter' || e.type === 'dragover') {
        mapDiv.classList.add('dropzone');
        map3DDiv.classList.add('dropzone');
      } else if (e.type === 'dragleave') {
        mapDiv.classList.remove('dropzone');
        map3DDiv.classList.remove('dropzone');
      } else if (e.type === 'drop') {
        mapDiv.classList.remove('dropzone');
        map3DDiv.classList.remove('dropzone');
        const file = e.dataTransfer.files[0];
        if (!file) return;
        if (file.name.endsWith('.kml')) {
          document.getElementById('kml-file').files = e.dataTransfer.files;
          importKML(document.getElementById('kml-file'));
        } else if (file.name.endsWith('.png')) {
          document.getElementById('png-file').files = e.dataTransfer.files;
          importPNG(document.getElementById('png-file'));
        }
      }
    }

    map.on('moveend', () => {
      if (!is3DMode && document.getElementById('lightning-layer-toggle').checked) {
        const currentBounds = map.getBounds();
        currentFiltered.forEach(s => {
          const strikeKey = `${s.time.toISOString()}_${s.coordinates[0]}_${s.coordinates[1]}`;
          const isNewStrike = !lastRenderedStrikes.has(strikeKey);
          const inBounds = currentBounds.contains([s.coordinates[1], s.coordinates[0]]);
          if (isNewStrike && inBounds) {
            playThunderSound();
            addLightningFlash2D(s.coordinates[1], s.coordinates[0]);
          }
        });
      }
    });

    map3D.on('moveend', () => {
      if (is3DMode && document.getElementById('lightning-layer-toggle').checked) {
        update3DView();
      }
    });
    initializeDrawControl();
    initializeDragAndDrop();
    fetchData();
    setRefreshInterval();
  </script>
<script>
